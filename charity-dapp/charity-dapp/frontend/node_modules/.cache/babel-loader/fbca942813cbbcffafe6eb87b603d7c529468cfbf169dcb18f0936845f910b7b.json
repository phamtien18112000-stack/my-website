{"ast":null,"code":"import { BcsEnum, BcsStruct, BcsTuple, BcsType, bigUIntBcsType, dynamicSizeBcsType, fixedSizeBcsType, lazyBcsType, stringLikeBcsType, uIntBcsType } from \"./bcs-type.js\";\nimport { ulebEncode } from \"./uleb.js\";\nfunction fixedArray(size, type, options) {\n  return new BcsType({\n    read: reader => {\n      const result = new Array(size);\n      for (let i = 0; i < size; i++) {\n        result[i] = type.read(reader);\n      }\n      return result;\n    },\n    write: (value, writer) => {\n      for (const item of value) {\n        type.write(item, writer);\n      }\n    },\n    ...options,\n    name: options?.name ?? `${type.name}[${size}]`,\n    validate: value => {\n      options?.validate?.(value);\n      if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n        throw new TypeError(`Expected array, found ${typeof value}`);\n      }\n      if (value.length !== size) {\n        throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n      }\n    }\n  });\n}\nfunction option(type) {\n  return bcs.enum(`Option<${type.name}>`, {\n    None: null,\n    Some: type\n  }).transform({\n    input: value => {\n      if (value == null) {\n        return {\n          None: true\n        };\n      }\n      return {\n        Some: value\n      };\n    },\n    output: value => {\n      if (value.$kind === \"Some\") {\n        return value.Some;\n      }\n      return null;\n    }\n  });\n}\nfunction vector(type, options) {\n  return new BcsType({\n    read: reader => {\n      const length = reader.readULEB();\n      const result = new Array(length);\n      for (let i = 0; i < length; i++) {\n        result[i] = type.read(reader);\n      }\n      return result;\n    },\n    write: (value, writer) => {\n      writer.writeULEB(value.length);\n      for (const item of value) {\n        type.write(item, writer);\n      }\n    },\n    ...options,\n    name: options?.name ?? `vector<${type.name}>`,\n    validate: value => {\n      options?.validate?.(value);\n      if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n        throw new TypeError(`Expected array, found ${typeof value}`);\n      }\n    }\n  });\n}\nfunction map(keyType, valueType) {\n  return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n    name: `Map<${keyType.name}, ${valueType.name}>`,\n    input: value => {\n      return [...value.entries()];\n    },\n    output: value => {\n      const result = /* @__PURE__ */new Map();\n      for (const [key, val] of value) {\n        result.set(key, val);\n      }\n      return result;\n    }\n  });\n}\nconst bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options,\n      name: options?.name ?? \"u8\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options,\n      name: options?.name ?? \"u16\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options,\n      name: options?.name ?? \"u32\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options,\n      name: options?.name ?? \"u64\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options,\n      name: options?.name ?? \"u128\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options,\n      name: options?.name ?? \"u256\"\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      size: 1,\n      read: reader => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      name: options?.name ?? \"bool\",\n      validate: value => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      read: reader => reader.readULEB(),\n      serialize: value => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options,\n      name: options?.name ?? \"uleb128\"\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      size,\n      read: reader => reader.readBytes(size),\n      write: (value, writer) => {\n        writer.writeBytes(new Uint8Array(value));\n      },\n      ...options,\n      name: options?.name ?? `bytes[${size}]`,\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length byte array\n   *\n   * @example\n   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n   */\n  byteVector(options) {\n    return new BcsType({\n      read: reader => {\n        const length = reader.readULEB();\n        return reader.readBytes(length);\n      },\n      write: (value, writer) => {\n        const array = new Uint8Array(value);\n        writer.writeULEB(array.length);\n        writer.writeBytes(array);\n      },\n      ...options,\n      name: options?.name ?? \"vector<u8>\",\n      serializedSize: value => {\n        const length = \"length\" in value ? value.length : null;\n        return length == null ? null : ulebEncode(length).length + length;\n      },\n      validate: value => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      toBytes: value => new TextEncoder().encode(value),\n      fromBytes: bytes => new TextDecoder().decode(bytes),\n      ...options,\n      name: options?.name ?? \"string\"\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray,\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option,\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector,\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(fields, options) {\n    return new BcsTuple({\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    return new BcsStruct({\n      name,\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, fields, options) {\n    return new BcsEnum({\n      name,\n      fields,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map,\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\nexport { bcs };\n//# sourceMappingURL=bcs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}