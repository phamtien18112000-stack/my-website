{"ast":null,"code":"import { is } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { ArgumentSchema } from \"./data/internal.js\";\nfunction extractMutableReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"MutableReference\" in normalizedType ? normalizedType.MutableReference : void 0;\n}\nfunction extractReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"Reference\" in normalizedType ? normalizedType.Reference : void 0;\n}\nfunction extractStructTag(normalizedType) {\n  if (typeof normalizedType === \"object\" && \"Struct\" in normalizedType) {\n    return normalizedType;\n  }\n  const ref = extractReference(normalizedType);\n  const mutRef = extractMutableReference(normalizedType);\n  if (typeof ref === \"object\" && \"Struct\" in ref) {\n    return ref;\n  }\n  if (typeof mutRef === \"object\" && \"Struct\" in mutRef) {\n    return mutRef;\n  }\n  return void 0;\n}\nfunction getIdFromCallArg(arg) {\n  if (typeof arg === \"string\") {\n    return normalizeSuiAddress(arg);\n  }\n  if (arg.Object) {\n    if (arg.Object.ImmOrOwnedObject) {\n      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n    }\n    if (arg.Object.Receiving) {\n      return normalizeSuiAddress(arg.Object.Receiving.objectId);\n    }\n    return normalizeSuiAddress(arg.Object.SharedObject.objectId);\n  }\n  if (arg.UnresolvedObject) {\n    return normalizeSuiAddress(arg.UnresolvedObject.objectId);\n  }\n  return void 0;\n}\nfunction isArgument(value) {\n  return is(ArgumentSchema, value);\n}\nfunction remapCommandArguments(command, inputMapping, commandMapping) {\n  const remapArg = arg => {\n    switch (arg.$kind) {\n      case \"Input\":\n        {\n          const newInputIndex = inputMapping.get(arg.Input);\n          if (newInputIndex === void 0) {\n            throw new Error(`Input ${arg.Input} not found in input mapping`);\n          }\n          return {\n            ...arg,\n            Input: newInputIndex\n          };\n        }\n      case \"Result\":\n        {\n          const newCommandIndex = commandMapping.get(arg.Result);\n          if (newCommandIndex !== void 0) {\n            return {\n              ...arg,\n              Result: newCommandIndex\n            };\n          }\n          return arg;\n        }\n      case \"NestedResult\":\n        {\n          const newCommandIndex = commandMapping.get(arg.NestedResult[0]);\n          if (newCommandIndex !== void 0) {\n            return {\n              ...arg,\n              NestedResult: [newCommandIndex, arg.NestedResult[1]]\n            };\n          }\n          return arg;\n        }\n      default:\n        return arg;\n    }\n  };\n  switch (command.$kind) {\n    case \"MoveCall\":\n      command.MoveCall.arguments = command.MoveCall.arguments.map(remapArg);\n      break;\n    case \"TransferObjects\":\n      command.TransferObjects.objects = command.TransferObjects.objects.map(remapArg);\n      command.TransferObjects.address = remapArg(command.TransferObjects.address);\n      break;\n    case \"SplitCoins\":\n      command.SplitCoins.coin = remapArg(command.SplitCoins.coin);\n      command.SplitCoins.amounts = command.SplitCoins.amounts.map(remapArg);\n      break;\n    case \"MergeCoins\":\n      command.MergeCoins.destination = remapArg(command.MergeCoins.destination);\n      command.MergeCoins.sources = command.MergeCoins.sources.map(remapArg);\n      break;\n    case \"MakeMoveVec\":\n      command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(remapArg);\n      break;\n    case \"Upgrade\":\n      command.Upgrade.ticket = remapArg(command.Upgrade.ticket);\n      break;\n    case \"$Intent\":\n      {\n        const inputs = command.$Intent.inputs;\n        command.$Intent.inputs = {};\n        for (const [key, value] of Object.entries(inputs)) {\n          command.$Intent.inputs[key] = Array.isArray(value) ? value.map(remapArg) : remapArg(value);\n        }\n        break;\n      }\n    case \"Publish\":\n      break;\n  }\n}\nexport { extractMutableReference, extractReference, extractStructTag, getIdFromCallArg, isArgument, remapCommandArguments };\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}