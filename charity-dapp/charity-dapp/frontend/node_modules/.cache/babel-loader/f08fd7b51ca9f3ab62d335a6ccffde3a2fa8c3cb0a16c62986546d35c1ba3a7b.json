{"ast":null,"code":"import { hexToBytes } from \"@noble/hashes/utils\";\nimport { poseidonHash } from \"./poseidon.js\";\nconst MAX_KEY_CLAIM_NAME_LENGTH = 32;\nconst MAX_KEY_CLAIM_VALUE_LENGTH = 115;\nconst MAX_AUD_VALUE_LENGTH = 145;\nconst PACK_WIDTH = 248;\nfunction findFirstNonZeroIndex(bytes) {\n  for (let i = 0; i < bytes.length; i++) {\n    if (bytes[i] !== 0) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction toPaddedBigEndianBytes(num, width) {\n  const hex = num.toString(16);\n  return hexToBytes(hex.padStart(width * 2, \"0\").slice(-width * 2));\n}\nfunction toBigEndianBytes(num, width) {\n  const bytes = toPaddedBigEndianBytes(num, width);\n  const firstNonZeroIndex = findFirstNonZeroIndex(bytes);\n  if (firstNonZeroIndex === -1) {\n    return new Uint8Array([0]);\n  }\n  return bytes.slice(firstNonZeroIndex);\n}\nfunction getExtendedEphemeralPublicKey(publicKey) {\n  return publicKey.toSuiPublicKey();\n}\nfunction chunkArray(array, chunk_size) {\n  const chunks = Array(Math.ceil(array.length / chunk_size));\n  const revArray = array.reverse();\n  for (let i = 0; i < chunks.length; i++) {\n    chunks[i] = revArray.slice(i * chunk_size, (i + 1) * chunk_size).reverse();\n  }\n  return chunks.reverse();\n}\nfunction bytesBEToBigInt(bytes) {\n  const hex = bytes.map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  if (hex.length === 0) {\n    return BigInt(0);\n  }\n  return BigInt(\"0x\" + hex);\n}\nfunction hashASCIIStrToField(str, maxSize) {\n  if (str.length > maxSize) {\n    throw new Error(`String ${str} is longer than ${maxSize} chars`);\n  }\n  const strPadded = str.padEnd(maxSize, String.fromCharCode(0)).split(\"\").map(c => c.charCodeAt(0));\n  const chunkSize = PACK_WIDTH / 8;\n  const packed = chunkArray(strPadded, chunkSize).map(chunk => bytesBEToBigInt(chunk));\n  return poseidonHash(packed);\n}\nfunction genAddressSeed(salt, name, value, aud, max_name_length = MAX_KEY_CLAIM_NAME_LENGTH, max_value_length = MAX_KEY_CLAIM_VALUE_LENGTH, max_aud_length = MAX_AUD_VALUE_LENGTH) {\n  return poseidonHash([hashASCIIStrToField(name, max_name_length), hashASCIIStrToField(value, max_value_length), hashASCIIStrToField(aud, max_aud_length), poseidonHash([BigInt(salt)])]);\n}\nfunction normalizeZkLoginIssuer(iss) {\n  if (iss === \"accounts.google.com\") {\n    return \"https://accounts.google.com\";\n  }\n  return iss;\n}\nexport { chunkArray, genAddressSeed, getExtendedEphemeralPublicKey, hashASCIIStrToField, normalizeZkLoginIssuer, toBigEndianBytes, toPaddedBigEndianBytes };\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}