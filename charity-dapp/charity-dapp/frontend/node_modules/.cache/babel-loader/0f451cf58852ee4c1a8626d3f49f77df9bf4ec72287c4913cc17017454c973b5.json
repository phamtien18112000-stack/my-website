{"ast":null,"code":"import { toBase58 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { ArgumentSchema, TransactionDataSchema } from \"./data/internal.js\";\nimport { transactionDataFromV1 } from \"./data/v1.js\";\nimport { hashTypedData } from \"./hash.js\";\nimport { getIdFromCallArg, remapCommandArguments } from \"./utils.js\";\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionDataBuilder {\n  constructor(clone) {\n    this.version = 2;\n    this.sender = clone?.sender ?? null;\n    this.expiration = clone?.expiration ?? null;\n    this.inputs = clone?.inputs ?? [];\n    this.commands = clone?.commands ?? [];\n    this.gasData = clone?.gasData ?? {\n      budget: null,\n      price: null,\n      owner: null,\n      payment: null\n    };\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = kind.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: null,\n      expiration: null,\n      gasData: {\n        budget: null,\n        owner: null,\n        payment: null,\n        price: null\n      },\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData?.V1;\n    const programmableTx = data.kind.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasData: data.gasData,\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static restore(data) {\n    if (data.version === 2) {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, data));\n    } else {\n      return new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n    }\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toBase58(hash);\n  }\n  // @deprecated use gasData instead\n  get gasConfig() {\n    return this.gasData;\n  }\n  // @deprecated use gasData instead\n  set gasConfig(value) {\n    this.gasData = value;\n  }\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind\n  } = {}) {\n    const inputs = this.inputs;\n    const commands = this.commands;\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        commands\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, {\n        maxSize: maxSizeBytes\n      }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasData = {\n      ...this.gasData,\n      ...overrides?.gasConfig,\n      ...overrides?.gasData\n    };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasData.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasData.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasData.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : {\n        None: true\n      },\n      gasData: {\n        payment: gasData.payment,\n        owner: prepareSuiAddress(this.gasData.owner ?? sender),\n        price: BigInt(gasData.price),\n        budget: BigInt(gasData.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          commands\n        }\n      }\n    };\n    return bcs.TransactionData.serialize({\n      V1: transactionData\n    }, {\n      maxSize: maxSizeBytes\n    }).toBytes();\n  }\n  addInput(type, arg) {\n    const index = this.inputs.length;\n    this.inputs.push(arg);\n    return {\n      Input: index,\n      type,\n      $kind: \"Input\"\n    };\n  }\n  getInputUses(index, fn) {\n    this.mapArguments((arg, command) => {\n      if (arg.$kind === \"Input\" && arg.Input === index) {\n        fn(arg, command);\n      }\n      return arg;\n    });\n  }\n  mapCommandArguments(index, fn) {\n    const command = this.commands[index];\n    switch (command.$kind) {\n      case \"MoveCall\":\n        command.MoveCall.arguments = command.MoveCall.arguments.map(arg => fn(arg, command, index));\n        break;\n      case \"TransferObjects\":\n        command.TransferObjects.objects = command.TransferObjects.objects.map(arg => fn(arg, command, index));\n        command.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n        break;\n      case \"SplitCoins\":\n        command.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n        command.SplitCoins.amounts = command.SplitCoins.amounts.map(arg => fn(arg, command, index));\n        break;\n      case \"MergeCoins\":\n        command.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n        command.MergeCoins.sources = command.MergeCoins.sources.map(arg => fn(arg, command, index));\n        break;\n      case \"MakeMoveVec\":\n        command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(arg => fn(arg, command, index));\n        break;\n      case \"Upgrade\":\n        command.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n        break;\n      case \"$Intent\":\n        const inputs = command.$Intent.inputs;\n        command.$Intent.inputs = {};\n        for (const [key, value] of Object.entries(inputs)) {\n          command.$Intent.inputs[key] = Array.isArray(value) ? value.map(arg => fn(arg, command, index)) : fn(value, command, index);\n        }\n        break;\n      case \"Publish\":\n        break;\n      default:\n        throw new Error(`Unexpected transaction kind: ${command.$kind}`);\n    }\n  }\n  mapArguments(fn) {\n    for (const commandIndex of this.commands.keys()) {\n      this.mapCommandArguments(commandIndex, fn);\n    }\n  }\n  replaceCommand(index, replacement, resultIndex = index) {\n    if (!Array.isArray(replacement)) {\n      this.commands[index] = replacement;\n      return;\n    }\n    const sizeDiff = replacement.length - 1;\n    this.commands.splice(index, 1, ...structuredClone(replacement));\n    this.mapArguments((arg, _command, commandIndex) => {\n      if (commandIndex < index + replacement.length) {\n        return arg;\n      }\n      if (typeof resultIndex !== \"number\") {\n        if (arg.$kind === \"Result\" && arg.Result === index || arg.$kind === \"NestedResult\" && arg.NestedResult[0] === index) {\n          if (!(\"NestedResult\" in arg) || arg.NestedResult[1] === 0) {\n            return parse(ArgumentSchema, structuredClone(resultIndex));\n          } else {\n            throw new Error(`Cannot replace command ${index} with a specific result type: NestedResult[${index}, ${arg.NestedResult[1]}] references a nested element that cannot be mapped to the replacement result`);\n          }\n        }\n      }\n      switch (arg.$kind) {\n        case \"Result\":\n          if (arg.Result === index && typeof resultIndex === \"number\") {\n            arg.Result = resultIndex;\n          }\n          if (arg.Result > index) {\n            arg.Result += sizeDiff;\n          }\n          break;\n        case \"NestedResult\":\n          if (arg.NestedResult[0] === index && typeof resultIndex === \"number\") {\n            return {\n              $kind: \"NestedResult\",\n              NestedResult: [resultIndex, arg.NestedResult[1]]\n            };\n          }\n          if (arg.NestedResult[0] > index) {\n            arg.NestedResult[0] += sizeDiff;\n          }\n          break;\n      }\n      return arg;\n    });\n  }\n  replaceCommandWithTransaction(index, otherTransaction, result) {\n    if (result.$kind !== \"Result\" && result.$kind !== \"NestedResult\") {\n      throw new Error(\"Result must be of kind Result or NestedResult\");\n    }\n    this.insertTransaction(index, otherTransaction);\n    this.replaceCommand(index + otherTransaction.commands.length, [], \"Result\" in result ? {\n      NestedResult: [result.Result + index, 0]\n    } : {\n      NestedResult: [result.NestedResult[0] + index, result.NestedResult[1]]\n    });\n  }\n  insertTransaction(atCommandIndex, otherTransaction) {\n    const inputMapping = /* @__PURE__ */new Map();\n    const commandMapping = /* @__PURE__ */new Map();\n    for (let i = 0; i < otherTransaction.inputs.length; i++) {\n      const otherInput = otherTransaction.inputs[i];\n      const id = getIdFromCallArg(otherInput);\n      let existingIndex = -1;\n      if (id !== void 0) {\n        existingIndex = this.inputs.findIndex(input => getIdFromCallArg(input) === id);\n        if (existingIndex !== -1 && this.inputs[existingIndex].Object?.SharedObject && otherInput.Object?.SharedObject) {\n          this.inputs[existingIndex].Object.SharedObject.mutable = this.inputs[existingIndex].Object.SharedObject.mutable || otherInput.Object.SharedObject.mutable;\n        }\n      }\n      if (existingIndex !== -1) {\n        inputMapping.set(i, existingIndex);\n      } else {\n        const newIndex = this.inputs.length;\n        this.inputs.push(otherInput);\n        inputMapping.set(i, newIndex);\n      }\n    }\n    for (let i = 0; i < otherTransaction.commands.length; i++) {\n      commandMapping.set(i, atCommandIndex + i);\n    }\n    const remappedCommands = [];\n    for (let i = 0; i < otherTransaction.commands.length; i++) {\n      const command = structuredClone(otherTransaction.commands[i]);\n      remapCommandArguments(command, inputMapping, commandMapping);\n      remappedCommands.push(command);\n    }\n    this.commands.splice(atCommandIndex, 0, ...remappedCommands);\n    const sizeDiff = remappedCommands.length;\n    if (sizeDiff > 0) {\n      this.mapArguments((arg, _command, commandIndex) => {\n        if (commandIndex >= atCommandIndex && commandIndex < atCommandIndex + remappedCommands.length) {\n          return arg;\n        }\n        switch (arg.$kind) {\n          case \"Result\":\n            if (arg.Result >= atCommandIndex) {\n              arg.Result += sizeDiff;\n            }\n            break;\n          case \"NestedResult\":\n            if (arg.NestedResult[0] >= atCommandIndex) {\n              arg.NestedResult[0] += sizeDiff;\n            }\n            break;\n        }\n        return arg;\n      });\n    }\n  }\n  getDigest() {\n    const bytes = this.build({\n      onlyTransactionKind: false\n    });\n    return TransactionDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return parse(TransactionDataSchema, this);\n  }\n  shallowClone() {\n    return new TransactionDataBuilder({\n      version: this.version,\n      sender: this.sender,\n      expiration: this.expiration,\n      gasData: {\n        ...this.gasData\n      },\n      inputs: [...this.inputs],\n      commands: [...this.commands]\n    });\n  }\n  applyResolvedData(resolved) {\n    if (!this.sender) {\n      this.sender = resolved.sender ?? null;\n    }\n    if (!this.expiration) {\n      this.expiration = resolved.expiration ?? null;\n    }\n    if (!this.gasData.budget) {\n      this.gasData.budget = resolved.gasData.budget;\n    }\n    if (!this.gasData.owner) {\n      this.gasData.owner = resolved.gasData.owner ?? null;\n    }\n    if (!this.gasData.payment) {\n      this.gasData.payment = resolved.gasData.payment;\n    }\n    if (!this.gasData.price) {\n      this.gasData.price = resolved.gasData.price;\n    }\n    for (let i = 0; i < this.inputs.length; i++) {\n      const input = this.inputs[i];\n      const resolvedInput = resolved.inputs[i];\n      switch (input.$kind) {\n        case \"UnresolvedPure\":\n          if (resolvedInput.$kind !== \"Pure\") {\n            throw new Error(`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(resolvedInput)}`);\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n        case \"UnresolvedObject\":\n          if (resolvedInput.$kind !== \"Object\") {\n            throw new Error(`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(resolvedInput)}`);\n          }\n          if (resolvedInput.Object.$kind === \"ImmOrOwnedObject\" || resolvedInput.Object.$kind === \"Receiving\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.version != null && original.version !== resolved2.version || original.digest != null && original.digest !== resolved2.digest ||\n            // Objects with shared object properties should not resolve to owned objects\n            original.mutable != null || original.initialSharedVersion != null) {\n              throw new Error(`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`);\n            }\n          } else if (resolvedInput.Object.$kind === \"SharedObject\") {\n            const original = input.UnresolvedObject;\n            const resolved2 = resolvedInput.Object.SharedObject;\n            if (normalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved2.objectId) || original.initialSharedVersion != null && original.initialSharedVersion !== resolved2.initialSharedVersion || original.mutable != null && original.mutable !== resolved2.mutable ||\n            // Objects with owned object properties should not resolve to shared objects\n            original.version != null || original.digest != null) {\n              throw new Error(`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved2)}`);\n            }\n          } else {\n            throw new Error(`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(resolvedInput.Object)}`);\n          }\n          this.inputs[i] = resolvedInput;\n          break;\n      }\n    }\n  }\n}\nexport { TransactionDataBuilder };\n//# sourceMappingURL=TransactionData.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}