{"ast":null,"code":"import { TypeTagSerializer } from \"../bcs/type-tag-serializer.js\";\nimport { deriveDynamicFieldID } from \"../utils/dynamic-fields.js\";\nimport { normalizeStructTag, parseStructTag, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { Experimental_BaseClient } from \"./client.js\";\nimport { MvrClient } from \"./mvr.js\";\nconst DEFAULT_MVR_URLS = {\n  mainnet: \"https://mainnet.mvr.mystenlabs.com\",\n  testnet: \"https://testnet.mvr.mystenlabs.com\"\n};\nclass Experimental_CoreClient extends Experimental_BaseClient {\n  constructor(options) {\n    super(options);\n    this.core = this;\n    this.mvr = new MvrClient({\n      cache: this.cache.scope(\"core.mvr\"),\n      url: options.mvr?.url ?? DEFAULT_MVR_URLS[this.network],\n      pageSize: options.mvr?.pageSize,\n      overrides: options.mvr?.overrides\n    });\n  }\n  async getObject(options) {\n    const {\n      objectId\n    } = options;\n    const {\n      objects: [result]\n    } = await this.getObjects({\n      objectIds: [objectId],\n      signal: options.signal\n    });\n    if (result instanceof Error) {\n      throw result;\n    }\n    return {\n      object: result\n    };\n  }\n  async getDynamicField(options) {\n    const normalizedNameType = TypeTagSerializer.parseFromStr((await this.core.mvr.resolveType({\n      type: options.name.type\n    })).type);\n    const fieldId = deriveDynamicFieldID(options.parentId, normalizedNameType, options.name.bcs);\n    const {\n      objects: [fieldObject]\n    } = await this.getObjects({\n      objectIds: [fieldId],\n      signal: options.signal\n    });\n    if (fieldObject instanceof Error) {\n      throw fieldObject;\n    }\n    const fieldType = parseStructTag(fieldObject.type);\n    const content = await fieldObject.content;\n    return {\n      dynamicField: {\n        id: fieldObject.id,\n        digest: fieldObject.digest,\n        version: fieldObject.version,\n        type: fieldObject.type,\n        previousTransaction: fieldObject.previousTransaction,\n        name: {\n          type: typeof fieldType.typeParams[0] === \"string\" ? fieldType.typeParams[0] : normalizeStructTag(fieldType.typeParams[0]),\n          bcs: options.name.bcs\n        },\n        value: {\n          type: typeof fieldType.typeParams[1] === \"string\" ? fieldType.typeParams[1] : normalizeStructTag(fieldType.typeParams[1]),\n          bcs: content.slice(SUI_ADDRESS_LENGTH + options.name.bcs.length)\n        }\n      }\n    };\n  }\n  async waitForTransaction({\n    signal,\n    timeout = 60 * 1e3,\n    ...input\n  }) {\n    const abortSignal = signal ? AbortSignal.any([AbortSignal.timeout(timeout), signal]) : AbortSignal.timeout(timeout);\n    const abortPromise = new Promise((_, reject) => {\n      abortSignal.addEventListener(\"abort\", () => reject(abortSignal.reason));\n    });\n    abortPromise.catch(() => {});\n    while (true) {\n      abortSignal.throwIfAborted();\n      try {\n        return await this.getTransaction({\n          ...input,\n          signal: abortSignal\n        });\n      } catch {\n        await Promise.race([new Promise(resolve => setTimeout(resolve, 2e3)), abortPromise]);\n      }\n    }\n  }\n}\nexport { Experimental_CoreClient };\n//# sourceMappingURL=core.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}