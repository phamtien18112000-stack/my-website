{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _host, _path, _client, _redirect, _coinsByType, _contract, _ZkSendLinkBuilder_instances, objectsToTransfer_fn, createSendTransactionWithoutContract_fn, estimateClaimGasFee_fn, getCoinsByType_fn;\nimport { getFullnodeUrl, SuiClient } from \"@mysten/sui/client\";\nimport { decodeSuiPrivateKey } from \"@mysten/sui/cryptography\";\nimport { Ed25519Keypair } from \"@mysten/sui/keypairs/ed25519\";\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { normalizeStructTag, normalizeSuiAddress, SUI_TYPE_ARG, toBase64 } from \"@mysten/sui/utils\";\nimport { getContractIds, ZkBag } from \"./zk-bag.js\";\nconst DEFAULT_ZK_SEND_LINK_OPTIONS = {\n  host: \"https://getstashed.com\",\n  path: \"/claim\",\n  network: \"mainnet\"\n};\nconst SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);\nconst _ZkSendLinkBuilder = class _ZkSendLinkBuilder {\n  constructor({\n    host = DEFAULT_ZK_SEND_LINK_OPTIONS.host,\n    path = DEFAULT_ZK_SEND_LINK_OPTIONS.path,\n    keypair = new Ed25519Keypair(),\n    network = DEFAULT_ZK_SEND_LINK_OPTIONS.network,\n    client = new SuiClient({\n      url: getFullnodeUrl(network)\n    }),\n    sender,\n    redirect,\n    contract = getContractIds(network)\n  }) {\n    __privateAdd(this, _ZkSendLinkBuilder_instances);\n    this.objectIds = /* @__PURE__ */new Set();\n    this.objectRefs = [];\n    this.balances = /* @__PURE__ */new Map();\n    __privateAdd(this, _host);\n    __privateAdd(this, _path);\n    __privateAdd(this, _client);\n    __privateAdd(this, _redirect);\n    __privateAdd(this, _coinsByType, /* @__PURE__ */new Map());\n    __privateAdd(this, _contract);\n    __privateSet(this, _host, host);\n    __privateSet(this, _path, path);\n    __privateSet(this, _redirect, redirect);\n    this.keypair = keypair;\n    __privateSet(this, _client, client);\n    this.sender = normalizeSuiAddress(sender);\n    this.network = network;\n    if (contract) {\n      __privateSet(this, _contract, new ZkBag(contract.packageId, contract));\n    }\n  }\n  addClaimableMist(amount) {\n    this.addClaimableBalance(SUI_COIN_TYPE, amount);\n  }\n  addClaimableBalance(coinType, amount) {\n    const normalizedType = normalizeStructTag(coinType);\n    this.balances.set(normalizedType, (this.balances.get(normalizedType) ?? 0n) + amount);\n  }\n  addClaimableObject(id) {\n    this.objectIds.add(id);\n  }\n  addClaimableObjectRef(ref, type) {\n    this.objectRefs.push({\n      ref,\n      type\n    });\n  }\n  getLink() {\n    const link = new URL(__privateGet(this, _host));\n    link.pathname = __privateGet(this, _path);\n    link.hash = `${__privateGet(this, _contract) ? \"$\" : \"\"}${toBase64(decodeSuiPrivateKey(this.keypair.getSecretKey()).secretKey)}`;\n    if (this.network !== \"mainnet\") {\n      link.searchParams.set(\"network\", this.network);\n    }\n    if (__privateGet(this, _redirect)) {\n      link.searchParams.set(\"redirect_url\", __privateGet(this, _redirect).url);\n      if (__privateGet(this, _redirect).name) {\n        link.searchParams.set(\"name\", __privateGet(this, _redirect).name);\n      }\n    }\n    return link.toString();\n  }\n  async create({\n    signer,\n    ...options\n  }) {\n    const tx = await this.createSendTransaction(options);\n    const result = await __privateGet(this, _client).signAndExecuteTransaction({\n      transaction: await tx.build({\n        client: __privateGet(this, _client)\n      }),\n      signer,\n      options: {\n        showEffects: true\n      }\n    });\n    if (result.effects?.status.status !== \"success\") {\n      throw new Error(`Transaction failed: ${result.effects?.status.error ?? \"Unknown error\"}`);\n    }\n    if (options.waitForTransaction) {\n      await __privateGet(this, _client).waitForTransaction({\n        digest: result.digest\n      });\n    }\n    return result;\n  }\n  async createSendTransaction({\n    transaction = new Transaction(),\n    calculateGas\n  } = {}) {\n    if (!__privateGet(this, _contract)) {\n      return __privateMethod(this, _ZkSendLinkBuilder_instances, createSendTransactionWithoutContract_fn).call(this, {\n        transaction,\n        calculateGas\n      });\n    }\n    transaction.setSenderIfNotSet(this.sender);\n    return _ZkSendLinkBuilder.createLinks({\n      transaction,\n      network: this.network,\n      client: __privateGet(this, _client),\n      contract: __privateGet(this, _contract).ids,\n      links: [this]\n    });\n  }\n  async createSendToAddressTransaction({\n    transaction = new Transaction(),\n    address\n  }) {\n    const objectsToTransfer = (await __privateMethod(this, _ZkSendLinkBuilder_instances, objectsToTransfer_fn).call(this, transaction)).map(obj => obj.ref);\n    transaction.setSenderIfNotSet(this.sender);\n    transaction.transferObjects(objectsToTransfer, address);\n    return transaction;\n  }\n  static async createLinks({\n    links,\n    network = \"mainnet\",\n    client = new SuiClient({\n      url: getFullnodeUrl(network)\n    }),\n    transaction = new Transaction(),\n    contract: contractIds = getContractIds(network)\n  }) {\n    const contract = new ZkBag(contractIds.packageId, contractIds);\n    const store = transaction.object(contract.ids.bagStoreId);\n    const coinsByType = /* @__PURE__ */new Map();\n    const allIds = links.flatMap(link => [...link.objectIds]);\n    const sender = links[0].sender;\n    transaction.setSenderIfNotSet(sender);\n    await Promise.all([...new Set(links.flatMap(link => [...link.balances.keys()]))].map(async coinType => {\n      const coins = await client.getCoins({\n        coinType,\n        owner: sender\n      });\n      coinsByType.set(coinType, coins.data.filter(coin => !allIds.includes(coin.coinObjectId)));\n    }));\n    const objectRefs = /* @__PURE__ */new Map();\n    const pageSize = 50;\n    let offset = 0;\n    while (offset < allIds.length) {\n      let chunk = allIds.slice(offset, offset + pageSize);\n      offset += pageSize;\n      const objects = await client.multiGetObjects({\n        ids: chunk,\n        options: {\n          showType: true\n        }\n      });\n      for (const [i, res] of objects.entries()) {\n        if (!res.data || res.error) {\n          throw new Error(`Failed to load object ${chunk[i]} (${res.error?.code})`);\n        }\n        objectRefs.set(chunk[i], {\n          ref: transaction.objectRef({\n            version: res.data.version,\n            digest: res.data.digest,\n            objectId: res.data.objectId\n          }),\n          type: res.data.type\n        });\n      }\n    }\n    const mergedCoins = /* @__PURE__ */new Map([[SUI_COIN_TYPE, transaction.gas]]);\n    for (const [coinType, coins] of coinsByType) {\n      if (coinType === SUI_COIN_TYPE) {\n        continue;\n      }\n      const [first, ...rest] = coins.map(coin => transaction.objectRef({\n        objectId: coin.coinObjectId,\n        version: coin.version,\n        digest: coin.digest\n      }));\n      if (rest.length > 0) {\n        transaction.mergeCoins(first, rest);\n      }\n      mergedCoins.set(coinType, transaction.object(first));\n    }\n    for (const link of links) {\n      const receiver = link.keypair.toSuiAddress();\n      transaction.add(contract.new({\n        arguments: [store, receiver]\n      }));\n      link.objectRefs.forEach(({\n        ref,\n        type\n      }) => {\n        transaction.add(contract.add({\n          arguments: [store, receiver, ref],\n          typeArguments: [type]\n        }));\n      });\n      link.objectIds.forEach(id => {\n        const object = objectRefs.get(id);\n        if (!object) {\n          throw new Error(`Object ${id} not found`);\n        }\n        transaction.add(contract.add({\n          arguments: [store, receiver, object.ref],\n          typeArguments: [object.type]\n        }));\n      });\n    }\n    for (const [coinType, merged] of mergedCoins) {\n      const linksWithCoin = links.filter(link => link.balances.has(coinType));\n      if (linksWithCoin.length === 0) {\n        continue;\n      }\n      const balances = linksWithCoin.map(link => link.balances.get(coinType));\n      const splits = transaction.splitCoins(merged, balances);\n      for (const [i, link] of linksWithCoin.entries()) {\n        transaction.add(contract.add({\n          arguments: [store, link.keypair.toSuiAddress(), splits[i]],\n          typeArguments: [`0x2::coin::Coin<${coinType}>`]\n        }));\n      }\n    }\n    return transaction;\n  }\n};\n_host = new WeakMap();\n_path = new WeakMap();\n_client = new WeakMap();\n_redirect = new WeakMap();\n_coinsByType = new WeakMap();\n_contract = new WeakMap();\n_ZkSendLinkBuilder_instances = new WeakSet();\nobjectsToTransfer_fn = async function (tx) {\n  const objectIDs = [...this.objectIds];\n  const refsWithType = this.objectRefs.concat((objectIDs.length > 0 ? await __privateGet(this, _client).multiGetObjects({\n    ids: objectIDs,\n    options: {\n      showType: true\n    }\n  }) : []).map((res, i) => {\n    if (!res.data || res.error) {\n      throw new Error(`Failed to load object ${objectIDs[i]} (${res.error?.code})`);\n    }\n    return {\n      ref: tx.objectRef({\n        version: res.data.version,\n        digest: res.data.digest,\n        objectId: res.data.objectId\n      }),\n      type: res.data.type\n    };\n  }));\n  for (const [coinType, amount] of this.balances) {\n    if (coinType === SUI_COIN_TYPE) {\n      const [sui] = tx.splitCoins(tx.gas, [amount]);\n      refsWithType.push({\n        ref: sui,\n        type: `0x2::coin::Coin<${coinType}>`\n      });\n    } else {\n      const coins = (await __privateMethod(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType)).map(coin => coin.coinObjectId);\n      if (coins.length > 1) {\n        tx.mergeCoins(coins[0], coins.slice(1));\n      }\n      const [split] = tx.splitCoins(coins[0], [amount]);\n      refsWithType.push({\n        ref: split,\n        type: `0x2::coin::Coin<${coinType}>`\n      });\n    }\n  }\n  return refsWithType;\n};\ncreateSendTransactionWithoutContract_fn = async function ({\n  transaction: tx = new Transaction(),\n  calculateGas\n} = {}) {\n  const gasEstimateFromDryRun = await __privateMethod(this, _ZkSendLinkBuilder_instances, estimateClaimGasFee_fn).call(this);\n  const baseGasAmount = calculateGas ? await calculateGas({\n    balances: this.balances,\n    objects: [...this.objectIds],\n    gasEstimateFromDryRun\n  }) : gasEstimateFromDryRun * 2n;\n  const gasWithBuffer = baseGasAmount + 1013n;\n  const roundedGasAmount = gasWithBuffer - gasWithBuffer % 1000n - 13n;\n  const address = this.keypair.toSuiAddress();\n  const objectsToTransfer = (await __privateMethod(this, _ZkSendLinkBuilder_instances, objectsToTransfer_fn).call(this, tx)).map(obj => obj.ref);\n  const [gas] = tx.splitCoins(tx.gas, [roundedGasAmount]);\n  objectsToTransfer.push(gas);\n  tx.setSenderIfNotSet(this.sender);\n  tx.transferObjects(objectsToTransfer, address);\n  return tx;\n};\nestimateClaimGasFee_fn = async function () {\n  const tx = new Transaction();\n  tx.setSender(this.sender);\n  tx.setGasPayment([]);\n  tx.transferObjects([tx.gas], this.keypair.toSuiAddress());\n  const idsToTransfer = [...this.objectIds];\n  for (const [coinType] of this.balances) {\n    const coins = await __privateMethod(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType);\n    if (!coins.length) {\n      throw new Error(`Sending account does not contain any coins of type ${coinType}`);\n    }\n    idsToTransfer.push(coins[0].coinObjectId);\n  }\n  if (idsToTransfer.length > 0) {\n    tx.transferObjects(idsToTransfer.map(id => tx.object(id)), this.keypair.toSuiAddress());\n  }\n  const result = await __privateGet(this, _client).dryRunTransactionBlock({\n    transactionBlock: await tx.build({\n      client: __privateGet(this, _client)\n    })\n  });\n  return BigInt(result.effects.gasUsed.computationCost) + BigInt(result.effects.gasUsed.storageCost) - BigInt(result.effects.gasUsed.storageRebate);\n};\ngetCoinsByType_fn = async function (coinType) {\n  if (__privateGet(this, _coinsByType).has(coinType)) {\n    return __privateGet(this, _coinsByType).get(coinType);\n  }\n  const coins = await __privateGet(this, _client).getCoins({\n    coinType,\n    owner: this.sender\n  });\n  __privateGet(this, _coinsByType).set(coinType, coins.data);\n  return coins.data;\n};\nlet ZkSendLinkBuilder = _ZkSendLinkBuilder;\nexport { ZkSendLinkBuilder };\n//# sourceMappingURL=builder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}