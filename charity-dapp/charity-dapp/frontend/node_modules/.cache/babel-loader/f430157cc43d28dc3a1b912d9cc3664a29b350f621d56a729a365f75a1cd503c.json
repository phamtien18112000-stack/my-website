{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _client, _lastDigest;\nimport { bcs } from \"../../bcs/index.js\";\nimport { ObjectCache } from \"../ObjectCache.js\";\nimport { isTransaction } from \"../Transaction.js\";\nclass CachingTransactionExecutor {\n  constructor({\n    client,\n    ...options\n  }) {\n    __privateAdd(this, _client);\n    __privateAdd(this, _lastDigest, null);\n    __privateSet(this, _client, client);\n    this.cache = new ObjectCache(options);\n  }\n  /**\n   * Clears all Owned objects\n   * Immutable objects, Shared objects, and Move function definitions will be preserved\n   */\n  async reset() {\n    await Promise.all([this.cache.clearOwnedObjects(), this.cache.clearCustom(), this.waitForLastTransaction()]);\n  }\n  async buildTransaction({\n    transaction,\n    ...options\n  }) {\n    transaction.addBuildPlugin(this.cache.asPlugin());\n    return transaction.build({\n      client: __privateGet(this, _client),\n      ...options\n    });\n  }\n  async executeTransaction({\n    transaction,\n    options,\n    ...input\n  }) {\n    const bytes = isTransaction(transaction) ? await this.buildTransaction({\n      transaction\n    }) : transaction;\n    const results = await __privateGet(this, _client).executeTransactionBlock({\n      ...input,\n      transactionBlock: bytes,\n      options: {\n        ...options,\n        showRawEffects: true\n      }\n    });\n    if (results.rawEffects) {\n      const effects = bcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));\n      await this.applyEffects(effects);\n    }\n    return results;\n  }\n  async signAndExecuteTransaction({\n    options,\n    transaction,\n    ...input\n  }) {\n    transaction.setSenderIfNotSet(input.signer.toSuiAddress());\n    const bytes = await this.buildTransaction({\n      transaction\n    });\n    const {\n      signature\n    } = await input.signer.signTransaction(bytes);\n    const results = await this.executeTransaction({\n      transaction: bytes,\n      signature,\n      options\n    });\n    return results;\n  }\n  async applyEffects(effects) {\n    __privateSet(this, _lastDigest, effects.V2?.transactionDigest ?? null);\n    await this.cache.applyEffects(effects);\n  }\n  async waitForLastTransaction() {\n    if (__privateGet(this, _lastDigest)) {\n      await __privateGet(this, _client).waitForTransaction({\n        digest: __privateGet(this, _lastDigest)\n      });\n      __privateSet(this, _lastDigest, null);\n    }\n  }\n}\n_client = new WeakMap();\n_lastDigest = new WeakMap();\nexport { CachingTransactionExecutor };\n//# sourceMappingURL=caching.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}