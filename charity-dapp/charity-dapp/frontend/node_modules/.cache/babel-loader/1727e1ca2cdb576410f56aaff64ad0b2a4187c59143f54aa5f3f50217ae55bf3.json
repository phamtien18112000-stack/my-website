{"ast":null,"code":"import { array, boolean, check, integer, lazy, literal, nullable, nullish, number, object, optional, pipe, record, string, transform, tuple, union, unknown } from \"valibot\";\nimport { isValidSuiAddress, normalizeSuiAddress } from \"../../utils/sui-types.js\";\nfunction safeEnum(options) {\n  const unionOptions = Object.entries(options).map(([key, value]) => object({\n    [key]: value\n  }));\n  return pipe(union(unionOptions), transform(value => ({\n    ...value,\n    $kind: Object.keys(value)[0]\n  })));\n}\nconst SuiAddress = pipe(string(), transform(value => normalizeSuiAddress(value)), check(isValidSuiAddress));\nconst ObjectID = SuiAddress;\nconst BCSBytes = string();\nconst JsonU64 = pipe(union([string(), pipe(number(), integer())]), check(val => {\n  try {\n    BigInt(val);\n    return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n  } catch {\n    return false;\n  }\n}, \"Invalid u64\"));\nconst ObjectRefSchema = object({\n  objectId: SuiAddress,\n  version: JsonU64,\n  digest: string()\n});\nconst ArgumentSchema = pipe(union([object({\n  GasCoin: literal(true)\n}), object({\n  Input: pipe(number(), integer()),\n  type: optional(literal(\"pure\"))\n}), object({\n  Input: pipe(number(), integer()),\n  type: optional(literal(\"object\"))\n}), object({\n  Result: pipe(number(), integer())\n}), object({\n  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])\n})]), transform(value => ({\n  ...value,\n  $kind: Object.keys(value)[0]\n}))\n// Defined manually to add `type?: 'pure' | 'object'` to Input\n);\nconst GasDataSchema = object({\n  budget: nullable(JsonU64),\n  price: nullable(JsonU64),\n  owner: nullable(SuiAddress),\n  payment: nullable(array(ObjectRefSchema))\n});\nconst StructTagSchema = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  // type_params in rust, should be updated to use camelCase\n  typeParams: array(string())\n});\nconst OpenMoveTypeSignatureBodySchema = union([literal(\"address\"), literal(\"bool\"), literal(\"u8\"), literal(\"u16\"), literal(\"u32\"), literal(\"u64\"), literal(\"u128\"), literal(\"u256\"), object({\n  vector: lazy(() => OpenMoveTypeSignatureBodySchema)\n}), object({\n  datatype: object({\n    package: string(),\n    module: string(),\n    type: string(),\n    typeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema))\n  })\n}), object({\n  typeParameter: pipe(number(), integer())\n})]);\nconst OpenMoveTypeSignatureSchema = object({\n  ref: nullable(union([literal(\"&\"), literal(\"&mut\")])),\n  body: OpenMoveTypeSignatureBodySchema\n});\nconst ProgrammableMoveCallSchema = object({\n  package: ObjectID,\n  module: string(),\n  function: string(),\n  // snake case in rust\n  typeArguments: array(string()),\n  arguments: array(ArgumentSchema),\n  _argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema)))\n});\nconst $Intent = object({\n  name: string(),\n  inputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),\n  data: record(string(), unknown())\n});\nconst CommandSchema = safeEnum({\n  MoveCall: ProgrammableMoveCallSchema,\n  TransferObjects: object({\n    objects: array(ArgumentSchema),\n    address: ArgumentSchema\n  }),\n  SplitCoins: object({\n    coin: ArgumentSchema,\n    amounts: array(ArgumentSchema)\n  }),\n  MergeCoins: object({\n    destination: ArgumentSchema,\n    sources: array(ArgumentSchema)\n  }),\n  Publish: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID)\n  }),\n  MakeMoveVec: object({\n    type: nullable(string()),\n    elements: array(ArgumentSchema)\n  }),\n  Upgrade: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID),\n    package: ObjectID,\n    ticket: ArgumentSchema\n  }),\n  $Intent\n});\nconst ObjectArgSchema = safeEnum({\n  ImmOrOwnedObject: ObjectRefSchema,\n  SharedObject: object({\n    objectId: ObjectID,\n    // snake case in rust\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRefSchema\n});\nconst CallArgSchema = safeEnum({\n  Object: ObjectArgSchema,\n  Pure: object({\n    bytes: BCSBytes\n  }),\n  UnresolvedPure: object({\n    value: unknown()\n  }),\n  UnresolvedObject: object({\n    objectId: ObjectID,\n    version: optional(nullable(JsonU64)),\n    digest: optional(nullable(string())),\n    initialSharedVersion: optional(nullable(JsonU64)),\n    mutable: optional(nullable(boolean()))\n  })\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArgSchema,\n  Pure: object({\n    bytes: BCSBytes\n  })\n});\nconst TransactionExpiration = safeEnum({\n  None: literal(true),\n  Epoch: JsonU64\n});\nconst TransactionDataSchema = object({\n  version: literal(2),\n  sender: nullish(SuiAddress),\n  expiration: nullish(TransactionExpiration),\n  gasData: GasDataSchema,\n  inputs: array(CallArgSchema),\n  commands: array(CommandSchema)\n});\nexport { $Intent, ArgumentSchema, BCSBytes, CommandSchema, GasDataSchema, JsonU64, NormalizedCallArg, ObjectArgSchema, ObjectID, ObjectRefSchema, OpenMoveTypeSignatureBodySchema, OpenMoveTypeSignatureSchema, StructTagSchema, SuiAddress, TransactionDataSchema, TransactionExpiration, safeEnum };\n//# sourceMappingURL=internal.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}