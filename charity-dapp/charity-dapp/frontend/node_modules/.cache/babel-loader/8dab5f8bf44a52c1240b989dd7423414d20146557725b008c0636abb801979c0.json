{"ast":null,"code":"import { isValidNamedPackage, isValidNamedType } from \"../../utils/move-registry.js\";\nconst NAME_SEPARATOR = \"/\";\nconst findTransactionBlockNames = builder => {\n  const packages = /* @__PURE__ */new Set();\n  const types = /* @__PURE__ */new Set();\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      getNamesFromTypeList([command.MakeMoveVec.type]).forEach(type => {\n        types.add(type);\n      });\n      continue;\n    }\n    if (!(\"MoveCall\" in command)) continue;\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const pkg = tx.package.split(\"::\")[0];\n    if (pkg.includes(NAME_SEPARATOR)) {\n      if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n      packages.add(pkg);\n    }\n    getNamesFromTypeList(tx.typeArguments ?? []).forEach(type => {\n      types.add(type);\n    });\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n};\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */new Set();\n  for (const type of types) {\n    if (type.includes(NAME_SEPARATOR)) {\n      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n      names.add(type);\n    }\n  }\n  return [...names];\n}\nconst replaceNames = (builder, cache) => {\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      if (!command.MakeMoveVec.type.includes(NAME_SEPARATOR)) continue;\n      if (!cache.types[command.MakeMoveVec.type]) throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n      command.MakeMoveVec.type = cache.types[command.MakeMoveVec.type];\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (name.includes(NAME_SEPARATOR) && !cache.packages[name]) throw new Error(`No address found for package: ${name}`);\n    if (name.includes(NAME_SEPARATOR)) {\n      nameParts[0] = cache.packages[name];\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!types[i].includes(NAME_SEPARATOR)) continue;\n      if (!cache.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n      types[i] = cache.types[types[i]];\n    }\n    tx.typeArguments = types;\n  }\n};\nconst listToRequests = (names, batchSize) => {\n  const results = [];\n  const uniqueNames = deduplicate(names.packages);\n  const uniqueTypes = deduplicate(names.types);\n  for (const [idx, name] of uniqueNames.entries()) {\n    results.push({\n      id: idx,\n      type: \"package\",\n      name\n    });\n  }\n  for (const [idx, type] of uniqueTypes.entries()) {\n    results.push({\n      id: idx + uniqueNames.length,\n      type: \"moveType\",\n      name: type\n    });\n  }\n  return batch(results, batchSize);\n};\nconst deduplicate = arr => [...new Set(arr)];\nconst batch = (arr, size) => {\n  const batches = [];\n  for (let i = 0; i < arr.length; i += size) {\n    batches.push(arr.slice(i, i + size));\n  }\n  return batches;\n};\nexport { findTransactionBlockNames, listToRequests, replaceNames };\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}