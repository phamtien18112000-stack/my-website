{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { parseSchemaCoordinate } from '../language/parser.mjs';\nimport { isEnumType, isInputObjectType, isInterfaceType, isObjectType } from '../type/definition.mjs';\n\n/**\n * A schema coordinate is resolved in the context of a GraphQL schema to\n * uniquely identify a schema element. It returns undefined if the schema\n * coordinate does not resolve to a schema element, meta-field, or introspection\n * schema element. It will throw if the containing schema element (if\n * applicable) does not exist.\n *\n * https://spec.graphql.org/draft/#sec-Schema-Coordinates.Semantics\n */\nexport function resolveSchemaCoordinate(schema, schemaCoordinate) {\n  return resolveASTSchemaCoordinate(schema, parseSchemaCoordinate(schemaCoordinate));\n}\n/**\n * TypeCoordinate : Name\n */\n\nfunction resolveTypeCoordinate(schema, schemaCoordinate) {\n  // 1. Let {typeName} be the value of {Name}.\n  const typeName = schemaCoordinate.name.value;\n  const type = schema.getType(typeName); // 2. Return the type in the {schema} named {typeName} if it exists.\n\n  if (type == null) {\n    return;\n  }\n  return {\n    kind: 'NamedType',\n    type\n  };\n}\n/**\n * MemberCoordinate : Name . Name\n */\n\nfunction resolveMemberCoordinate(schema, schemaCoordinate) {\n  // 1. Let {typeName} be the value of the first {Name}.\n  // 2. Let {type} be the type in the {schema} named {typeName}.\n  const typeName = schemaCoordinate.name.value;\n  const type = schema.getType(typeName); // 3. Assert: {type} must exist, and must be an Enum, Input Object, Object or Interface type.\n\n  if (!type) {\n    throw new Error(`Expected ${inspect(typeName)} to be defined as a type in the schema.`);\n  }\n  if (!isEnumType(type) && !isInputObjectType(type) && !isObjectType(type) && !isInterfaceType(type)) {\n    throw new Error(`Expected ${inspect(typeName)} to be an Enum, Input Object, Object or Interface type.`);\n  } // 4. If {type} is an Enum type:\n\n  if (isEnumType(type)) {\n    // 1. Let {enumValueName} be the value of the second {Name}.\n    const enumValueName = schemaCoordinate.memberName.value;\n    const enumValue = type.getValue(enumValueName); // 2. Return the enum value of {type} named {enumValueName} if it exists.\n\n    if (enumValue == null) {\n      return;\n    }\n    return {\n      kind: 'EnumValue',\n      type,\n      enumValue\n    };\n  } // 5. Otherwise, if {type} is an Input Object type:\n\n  if (isInputObjectType(type)) {\n    // 1. Let {inputFieldName} be the value of the second {Name}.\n    const inputFieldName = schemaCoordinate.memberName.value;\n    const inputField = type.getFields()[inputFieldName]; // 2. Return the input field of {type} named {inputFieldName} if it exists.\n\n    if (inputField == null) {\n      return;\n    }\n    return {\n      kind: 'InputField',\n      type,\n      inputField\n    };\n  } // 6. Otherwise:\n  // 1. Let {fieldName} be the value of the second {Name}.\n\n  const fieldName = schemaCoordinate.memberName.value;\n  const field = type.getFields()[fieldName]; // 2. Return the field of {type} named {fieldName} if it exists.\n\n  if (field == null) {\n    return;\n  }\n  return {\n    kind: 'Field',\n    type,\n    field\n  };\n}\n/**\n * ArgumentCoordinate : Name . Name ( Name : )\n */\n\nfunction resolveArgumentCoordinate(schema, schemaCoordinate) {\n  // 1. Let {typeName} be the value of the first {Name}.\n  // 2. Let {type} be the type in the {schema} named {typeName}.\n  const typeName = schemaCoordinate.name.value;\n  const type = schema.getType(typeName); // 3. Assert: {type} must exist, and be an Object or Interface type.\n\n  if (type == null) {\n    throw new Error(`Expected ${inspect(typeName)} to be defined as a type in the schema.`);\n  }\n  if (!isObjectType(type) && !isInterfaceType(type)) {\n    throw new Error(`Expected ${inspect(typeName)} to be an object type or interface type.`);\n  } // 4. Let {fieldName} be the value of the second {Name}.\n  // 5. Let {field} be the field of {type} named {fieldName}.\n\n  const fieldName = schemaCoordinate.fieldName.value;\n  const field = type.getFields()[fieldName]; // 7. Assert: {field} must exist.\n\n  if (field == null) {\n    throw new Error(`Expected ${inspect(fieldName)} to exist as a field of type ${inspect(typeName)} in the schema.`);\n  } // 7. Let {fieldArgumentName} be the value of the third {Name}.\n\n  const fieldArgumentName = schemaCoordinate.argumentName.value;\n  const fieldArgument = field.args.find(arg => arg.name === fieldArgumentName); // 8. Return the argument of {field} named {fieldArgumentName} if it exists.\n\n  if (fieldArgument == null) {\n    return;\n  }\n  return {\n    kind: 'FieldArgument',\n    type,\n    field,\n    fieldArgument\n  };\n}\n/**\n * DirectiveCoordinate : \\@ Name\n */\n\nfunction resolveDirectiveCoordinate(schema, schemaCoordinate) {\n  // 1. Let {directiveName} be the value of {Name}.\n  const directiveName = schemaCoordinate.name.value;\n  const directive = schema.getDirective(directiveName); // 2. Return the directive in the {schema} named {directiveName} if it exists.\n\n  if (!directive) {\n    return;\n  }\n  return {\n    kind: 'Directive',\n    directive\n  };\n}\n/**\n * DirectiveArgumentCoordinate : \\@ Name ( Name : )\n */\n\nfunction resolveDirectiveArgumentCoordinate(schema, schemaCoordinate) {\n  // 1. Let {directiveName} be the value of the first {Name}.\n  // 2. Let {directive} be the directive in the {schema} named {directiveName}.\n  const directiveName = schemaCoordinate.name.value;\n  const directive = schema.getDirective(directiveName); // 3. Assert {directive} must exist.\n\n  if (!directive) {\n    throw new Error(`Expected ${inspect(directiveName)} to be defined as a directive in the schema.`);\n  } // 4. Let {directiveArgumentName} be the value of the second {Name}.\n\n  const {\n    argumentName: {\n      value: directiveArgumentName\n    }\n  } = schemaCoordinate;\n  const directiveArgument = directive.args.find(arg => arg.name === directiveArgumentName); // 5. Return the argument of {directive} named {directiveArgumentName} if it exists.\n\n  if (!directiveArgument) {\n    return;\n  }\n  return {\n    kind: 'DirectiveArgument',\n    directive,\n    directiveArgument\n  };\n}\n/**\n * Resolves schema coordinate from a parsed SchemaCoordinate node.\n */\n\nexport function resolveASTSchemaCoordinate(schema, schemaCoordinate) {\n  switch (schemaCoordinate.kind) {\n    case Kind.TYPE_COORDINATE:\n      return resolveTypeCoordinate(schema, schemaCoordinate);\n    case Kind.MEMBER_COORDINATE:\n      return resolveMemberCoordinate(schema, schemaCoordinate);\n    case Kind.ARGUMENT_COORDINATE:\n      return resolveArgumentCoordinate(schema, schemaCoordinate);\n    case Kind.DIRECTIVE_COORDINATE:\n      return resolveDirectiveCoordinate(schema, schemaCoordinate);\n    case Kind.DIRECTIVE_ARGUMENT_COORDINATE:\n      return resolveDirectiveArgumentCoordinate(schema, schemaCoordinate);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}