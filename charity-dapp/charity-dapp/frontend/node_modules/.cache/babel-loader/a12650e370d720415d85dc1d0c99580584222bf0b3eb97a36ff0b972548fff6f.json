{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _popup, _id, _origin, _name, _network, _promise, _resolve, _reject, _interval, _listener, _StashedPopup_instances, cleanup_fn, _request;\nimport { parse, safeParse } from \"valibot\";\nimport { withResolvers } from \"../../utils/withResolvers.js\";\nimport { StashedRequest, StashedResponse } from \"./events.js\";\nconst DEFAULT_STASHED_ORIGIN = \"https://getstashed.com\";\nclass StashedPopup {\n  constructor({\n    name,\n    network,\n    origin = DEFAULT_STASHED_ORIGIN\n  }) {\n    __privateAdd(this, _StashedPopup_instances);\n    __privateAdd(this, _popup);\n    __privateAdd(this, _id);\n    __privateAdd(this, _origin);\n    __privateAdd(this, _name);\n    __privateAdd(this, _network);\n    __privateAdd(this, _promise);\n    __privateAdd(this, _resolve);\n    __privateAdd(this, _reject);\n    __privateAdd(this, _interval, null);\n    __privateAdd(this, _listener, event => {\n      if (event.origin !== __privateGet(this, _origin)) {\n        return;\n      }\n      const {\n        success,\n        output\n      } = safeParse(StashedResponse, event.data);\n      if (!success || output.id !== __privateGet(this, _id)) return;\n      __privateMethod(this, _StashedPopup_instances, cleanup_fn).call(this);\n      if (output.payload.type === \"reject\") {\n        __privateGet(this, _reject).call(this, new Error(\"User rejected the request\"));\n      } else if (output.payload.type === \"resolve\") {\n        __privateGet(this, _resolve).call(this, output.payload.data);\n      }\n    });\n    const popup = window.open(\"about:blank\", \"_blank\");\n    if (!popup) {\n      throw new Error(\"Failed to open new window\");\n    }\n    __privateSet(this, _popup, popup);\n    __privateSet(this, _id, crypto.randomUUID());\n    __privateSet(this, _origin, origin);\n    __privateSet(this, _name, name);\n    __privateSet(this, _network, network);\n    const {\n      promise,\n      resolve,\n      reject\n    } = withResolvers();\n    __privateSet(this, _promise, promise);\n    __privateSet(this, _resolve, resolve);\n    __privateSet(this, _reject, reject);\n    __privateSet(this, _interval, setInterval(() => {\n      try {\n        if (__privateGet(this, _popup).closed) {\n          __privateMethod(this, _StashedPopup_instances, cleanup_fn).call(this);\n          reject(new Error(\"User closed the Stashed window\"));\n        }\n      } catch {}\n    }, 1e3));\n  }\n  send({\n    type,\n    ...data\n  }) {\n    window.addEventListener(\"message\", __privateGet(this, _listener));\n    __privateGet(this, _popup).location.assign(`${__privateGet(this, _origin)}/dapp/${type}?${new URLSearchParams({\n      id: __privateGet(this, _id),\n      origin: window.origin,\n      network: __privateGet(this, _network),\n      name: __privateGet(this, _name)\n    })}${data ? `#${new URLSearchParams(data)}` : \"\"}`);\n    return __privateGet(this, _promise);\n  }\n  close() {\n    __privateMethod(this, _StashedPopup_instances, cleanup_fn).call(this);\n    __privateGet(this, _popup).close();\n  }\n}\n_popup = new WeakMap();\n_id = new WeakMap();\n_origin = new WeakMap();\n_name = new WeakMap();\n_network = new WeakMap();\n_promise = new WeakMap();\n_resolve = new WeakMap();\n_reject = new WeakMap();\n_interval = new WeakMap();\n_listener = new WeakMap();\n_StashedPopup_instances = new WeakSet();\ncleanup_fn = function () {\n  if (__privateGet(this, _interval)) {\n    clearInterval(__privateGet(this, _interval));\n    __privateSet(this, _interval, null);\n  }\n  window.removeEventListener(\"message\", __privateGet(this, _listener));\n};\nconst _StashedHost = class _StashedHost {\n  constructor(request) {\n    __privateAdd(this, _request);\n    if (typeof window === \"undefined\" || !window.opener) {\n      throw new Error(\"StashedHost can only be used in a window opened through `window.open`. `window.opener` is not available.\");\n    }\n    __privateSet(this, _request, request);\n  }\n  static fromUrl(url = window.location.href) {\n    const parsed = new URL(url);\n    const urlHashData = parsed.hash ? Object.fromEntries([...new URLSearchParams(parsed.hash.slice(1))]) : {};\n    const request = parse(StashedRequest, {\n      id: parsed.searchParams.get(\"id\"),\n      origin: parsed.searchParams.get(\"origin\"),\n      name: parsed.searchParams.get(\"name\"),\n      payload: {\n        type: parsed.pathname.split(\"/\").pop(),\n        ...urlHashData\n      }\n    });\n    return new _StashedHost(request);\n  }\n  getRequestData() {\n    return __privateGet(this, _request);\n  }\n  sendMessage(payload) {\n    window.opener.postMessage({\n      id: __privateGet(this, _request).id,\n      source: \"zksend-channel\",\n      payload\n    }, __privateGet(this, _request).origin);\n  }\n  close(payload) {\n    if (payload) {\n      this.sendMessage(payload);\n    }\n    window.close();\n  }\n};\n_request = new WeakMap();\nlet StashedHost = _StashedHost;\nexport { DEFAULT_STASHED_ORIGIN, StashedHost, StashedPopup, StashedRequest, StashedResponse };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}