{"ast":null,"code":"import { encodeContextObject } from './context.js';\nimport { WalletStandardErrorMessages } from './messages.js';\nvar StateType;\n(function (StateType) {\n  StateType[StateType[\"EscapeSequence\"] = 0] = \"EscapeSequence\";\n  StateType[StateType[\"Text\"] = 1] = \"Text\";\n  StateType[StateType[\"Variable\"] = 2] = \"Variable\";\n})(StateType || (StateType = {}));\nconst START_INDEX = 'i';\nconst TYPE = 't';\nexport function getHumanReadableErrorMessage(code, context = {}) {\n  const messageFormatString = WalletStandardErrorMessages[code];\n  if (messageFormatString.length === 0) {\n    return '';\n  }\n  let state;\n  function commitStateUpTo(endIndex) {\n    if (state[TYPE] === StateType.Variable) {\n      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n      fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);\n    } else if (state[TYPE] === StateType.Text) {\n      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n    }\n  }\n  const fragments = [];\n  messageFormatString.split('').forEach((char, ii) => {\n    if (ii === 0) {\n      state = {\n        [START_INDEX]: 0,\n        [TYPE]: messageFormatString[0] === '\\\\' ? StateType.EscapeSequence : messageFormatString[0] === '$' ? StateType.Variable : StateType.Text\n      };\n      return;\n    }\n    let nextState;\n    switch (state[TYPE]) {\n      case StateType.EscapeSequence:\n        nextState = {\n          [START_INDEX]: ii,\n          [TYPE]: StateType.Text\n        };\n        break;\n      case StateType.Text:\n        if (char === '\\\\') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.EscapeSequence\n          };\n        } else if (char === '$') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.Variable\n          };\n        }\n        break;\n      case StateType.Variable:\n        if (char === '\\\\') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.EscapeSequence\n          };\n        } else if (char === '$') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.Variable\n          };\n        } else if (!char.match(/\\w/)) {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.Text\n          };\n        }\n        break;\n    }\n    if (nextState) {\n      if (state !== nextState) {\n        commitStateUpTo(ii);\n      }\n      state = nextState;\n    }\n  });\n  commitStateUpTo();\n  return fragments.join('');\n}\nexport function getErrorMessage(code, context = {}) {\n  if (process.env.NODE_ENV !== 'production') {\n    return getHumanReadableErrorMessage(code, context);\n  } else {\n    let decodingAdviceMessage = `Wallet Standard error #${code}; Decode this error by running \\`npx @wallet-standard/errors decode -- ${code}`;\n    if (Object.keys(context).length) {\n      /**\n       * DANGER: Be sure that the shell command is escaped in such a way that makes it\n       *         impossible for someone to craft malicious context values that would result in\n       *         an exploit against anyone who bindly copy/pastes it into their terminal.\n       */\n      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n    }\n    return `${decodingAdviceMessage}\\``;\n  }\n}\n//# sourceMappingURL=message-formatter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}