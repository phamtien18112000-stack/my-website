{"ast":null,"code":"import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport { secp256r1 } from \"@noble/curves/p256\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { PasskeyAuthenticator } from \"../../bcs/bcs.js\";\nimport { bytesEqual, PublicKey } from \"../../cryptography/publickey.js\";\nimport { SIGNATURE_SCHEME_TO_FLAG } from \"../../cryptography/signature-scheme.js\";\nconst PASSKEY_PUBLIC_KEY_SIZE = 33;\nconst PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nconst PASSKEY_SIGNATURE_SIZE = 64;\nconst SECP256R1_SPKI_HEADER = new Uint8Array([48, 89,\n// SEQUENCE, length 89\n48, 19,\n// SEQUENCE, length 19\n6, 7,\n// OID, length 7\n42, 134, 72, 206, 61, 2, 1,\n// OID: 1.2.840.10045.2.1 (ecPublicKey)\n6, 8,\n// OID, length 8\n42, 134, 72, 206, 61, 3, 1, 7,\n// OID: 1.2.840.10045.3.1.7 (prime256v1/secp256r1)\n3, 66,\n// BIT STRING, length 66\n0\n// no unused bits\n]);\nclass PasskeyPublicKey extends PublicKey {\n  /**\n   * Create a new PasskeyPublicKey object\n   * @param value passkey public key as buffer or base-64 encoded string\n   */\n  constructor(value) {\n    super();\n    if (typeof value === \"string\") {\n      this.data = fromBase64(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n    if (this.data.length !== PASSKEY_PUBLIC_KEY_SIZE) {\n      throw new Error(`Invalid public key input. Expected ${PASSKEY_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`);\n    }\n  }\n  /**\n   * Checks if two passkey public keys are equal\n   */\n  equals(publicKey) {\n    return super.equals(publicKey);\n  }\n  /**\n   * Return the byte array representation of the Secp256r1 public key\n   */\n  toRawBytes() {\n    return this.data;\n  }\n  /**\n   * Return the Sui address associated with this Secp256r1 public key\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"Passkey\"];\n  }\n  /**\n   * Verifies that the signature is valid for for the provided message\n   */\n  async verify(message, signature) {\n    const parsed = parseSerializedPasskeySignature(signature);\n    const clientDataJSON = JSON.parse(parsed.clientDataJson);\n    if (clientDataJSON.type !== \"webauthn.get\") {\n      return false;\n    }\n    const parsedChallenge = fromBase64(clientDataJSON.challenge.replace(/-/g, \"+\").replace(/_/g, \"/\"));\n    if (!bytesEqual(message, parsedChallenge)) {\n      return false;\n    }\n    const pk = parsed.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE);\n    if (!bytesEqual(this.toRawBytes(), pk)) {\n      return false;\n    }\n    const payload = new Uint8Array([...parsed.authenticatorData, ...sha256(parsed.clientDataJson)]);\n    const sig = parsed.userSignature.slice(1, PASSKEY_SIGNATURE_SIZE + 1);\n    return secp256r1.verify(sig, sha256(payload), pk);\n  }\n}\nPasskeyPublicKey.SIZE = PASSKEY_PUBLIC_KEY_SIZE;\nfunction parseDerSPKI(derBytes) {\n  if (derBytes.length !== SECP256R1_SPKI_HEADER.length + PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n    throw new Error(\"Invalid DER length\");\n  }\n  for (let i = 0; i < SECP256R1_SPKI_HEADER.length; i++) {\n    if (derBytes[i] !== SECP256R1_SPKI_HEADER[i]) {\n      throw new Error(\"Invalid spki header\");\n    }\n  }\n  if (derBytes[SECP256R1_SPKI_HEADER.length] !== 4) {\n    throw new Error(\"Invalid point marker\");\n  }\n  return derBytes.slice(SECP256R1_SPKI_HEADER.length);\n}\nfunction parseSerializedPasskeySignature(signature) {\n  const bytes = typeof signature === \"string\" ? fromBase64(signature) : signature;\n  if (bytes[0] !== SIGNATURE_SCHEME_TO_FLAG.Passkey) {\n    throw new Error(\"Invalid signature scheme\");\n  }\n  const dec = PasskeyAuthenticator.parse(bytes.slice(1));\n  return {\n    signatureScheme: \"Passkey\",\n    serializedSignature: toBase64(bytes),\n    signature: bytes,\n    authenticatorData: dec.authenticatorData,\n    clientDataJson: dec.clientDataJson,\n    userSignature: new Uint8Array(dec.userSignature),\n    publicKey: new Uint8Array(dec.userSignature.slice(1 + PASSKEY_SIGNATURE_SIZE))\n  };\n}\nexport { PASSKEY_PUBLIC_KEY_SIZE, PASSKEY_SIGNATURE_SIZE, PASSKEY_UNCOMPRESSED_PUBLIC_KEY_SIZE, PasskeyPublicKey, SECP256R1_SPKI_HEADER, parseDerSPKI, parseSerializedPasskeySignature };\n//# sourceMappingURL=publickey.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}