{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _cache, _url, _pageSize, _overrides, _MvrClient_instances, mvrPackageDataLoader_get, mvrTypeDataLoader_get, resolvePackages_fn, resolveTypes_fn, fetch_fn;\nimport { chunk, DataLoader } from \"@mysten/utils\";\nimport { isValidNamedPackage, isValidNamedType } from \"../utils/move-registry.js\";\nimport { isValidSuiAddress, normalizeStructTag, normalizeSuiAddress, parseStructTag } from \"../utils/sui-types.js\";\nimport { PACKAGE_VERSION } from \"../version.js\";\nconst NAME_SEPARATOR = \"/\";\nconst MVR_API_HEADER = {\n  \"Mvr-Source\": `@mysten/sui@${PACKAGE_VERSION}`\n};\nclass MvrClient {\n  constructor({\n    cache,\n    url,\n    pageSize = 50,\n    overrides\n  }) {\n    __privateAdd(this, _MvrClient_instances);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _url);\n    __privateAdd(this, _pageSize);\n    __privateAdd(this, _overrides);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _url, url);\n    __privateSet(this, _pageSize, pageSize);\n    __privateSet(this, _overrides, {\n      packages: overrides?.packages,\n      types: overrides?.types\n    });\n    validateOverrides(__privateGet(this, _overrides));\n  }\n  async resolvePackage({\n    package: name\n  }) {\n    if (!hasMvrName(name)) {\n      return {\n        package: name\n      };\n    }\n    const resolved = await __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).load(name);\n    return {\n      package: resolved\n    };\n  }\n  async resolveType({\n    type\n  }) {\n    if (!hasMvrName(type)) {\n      return {\n        type\n      };\n    }\n    const mvrTypes = [...extractMvrTypes(type)];\n    const resolvedTypes = await __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(mvrTypes);\n    const typeMap = {};\n    for (let i = 0; i < mvrTypes.length; i++) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[mvrTypes[i]] = resolvedType;\n    }\n    return {\n      type: replaceMvrNames(type, typeMap)\n    };\n  }\n  async resolve({\n    types = [],\n    packages = []\n  }) {\n    const mvrTypes = /* @__PURE__ */new Set();\n    for (const type of types ?? []) {\n      extractMvrTypes(type, mvrTypes);\n    }\n    const typesArray = [...mvrTypes];\n    const [resolvedTypes, resolvedPackages] = await Promise.all([typesArray.length > 0 ? __privateGet(this, _MvrClient_instances, mvrTypeDataLoader_get).loadMany(typesArray) : [], packages.length > 0 ? __privateGet(this, _MvrClient_instances, mvrPackageDataLoader_get).loadMany(packages) : []]);\n    const typeMap = {\n      ...__privateGet(this, _overrides)?.types\n    };\n    for (const [i, type] of typesArray.entries()) {\n      const resolvedType = resolvedTypes[i];\n      if (resolvedType instanceof Error) {\n        throw resolvedType;\n      }\n      typeMap[type] = resolvedType;\n    }\n    const replacedTypes = {};\n    for (const type of types ?? []) {\n      const resolvedType = replaceMvrNames(type, typeMap);\n      replacedTypes[type] = {\n        type: resolvedType\n      };\n    }\n    const replacedPackages = {};\n    for (const [i, pkg] of (packages ?? []).entries()) {\n      const resolvedPkg = __privateGet(this, _overrides)?.packages?.[pkg] ?? resolvedPackages[i];\n      if (resolvedPkg instanceof Error) {\n        throw resolvedPkg;\n      }\n      replacedPackages[pkg] = {\n        package: resolvedPkg\n      };\n    }\n    return {\n      types: replacedTypes,\n      packages: replacedPackages\n    };\n  }\n}\n_cache = new WeakMap();\n_url = new WeakMap();\n_pageSize = new WeakMap();\n_overrides = new WeakMap();\n_MvrClient_instances = new WeakSet();\nmvrPackageDataLoader_get = function () {\n  return __privateGet(this, _cache).readSync([\"#mvrPackageDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async packages => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(`MVR Api URL is not set for the current client (resolving ${packages.join(\", \")})`);\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolvePackages_fn).call(this, packages);\n      return packages.map(pkg => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`));\n    });\n    const overrides = __privateGet(this, _overrides)?.packages;\n    if (overrides) {\n      for (const [pkg, id] of Object.entries(overrides)) {\n        loader.prime(pkg, id);\n      }\n    }\n    return loader;\n  });\n};\nmvrTypeDataLoader_get = function () {\n  return __privateGet(this, _cache).readSync([\"#mvrTypeDataLoader\", __privateGet(this, _url) ?? \"\"], () => {\n    const loader = new DataLoader(async types => {\n      if (!__privateGet(this, _url)) {\n        throw new Error(`MVR Api URL is not set for the current client (resolving ${types.join(\", \")})`);\n      }\n      const resolved = await __privateMethod(this, _MvrClient_instances, resolveTypes_fn).call(this, types);\n      return types.map(type => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n    });\n    const overrides = __privateGet(this, _overrides)?.types;\n    if (overrides) {\n      for (const [type, id] of Object.entries(overrides)) {\n        loader.prime(type, id);\n      }\n    }\n    return loader;\n  });\n};\nresolvePackages_fn = async function (packages) {\n  if (packages.length === 0) return {};\n  const batches = chunk(packages, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(batches.map(async batch => {\n    const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/resolution/bulk\", {\n      names: batch\n    });\n    if (!data?.resolution) return;\n    for (const pkg of Object.keys(data?.resolution)) {\n      const pkgData = data.resolution[pkg]?.package_id;\n      if (!pkgData) continue;\n      results[pkg] = pkgData;\n    }\n  }));\n  return results;\n};\nresolveTypes_fn = async function (types) {\n  if (types.length === 0) return {};\n  const batches = chunk(types, __privateGet(this, _pageSize));\n  const results = {};\n  await Promise.all(batches.map(async batch => {\n    const data = await __privateMethod(this, _MvrClient_instances, fetch_fn).call(this, \"/v1/struct-definition/bulk\", {\n      types: batch\n    });\n    if (!data?.resolution) return;\n    for (const type of Object.keys(data?.resolution)) {\n      const typeData = data.resolution[type]?.type_tag;\n      if (!typeData) continue;\n      results[type] = typeData;\n    }\n  }));\n  return results;\n};\nfetch_fn = async function (url, body) {\n  if (!__privateGet(this, _url)) {\n    throw new Error(\"MVR Api URL is not set for the current client\");\n  }\n  const response = await fetch(`${__privateGet(this, _url)}${url}`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...MVR_API_HEADER\n    },\n    body: JSON.stringify(body)\n  });\n  if (!response.ok) {\n    const errorBody = await response.json().catch(() => ({}));\n    throw new Error(`Failed to resolve types: ${errorBody?.message}`);\n  }\n  return response.json();\n};\nfunction validateOverrides(overrides) {\n  if (overrides?.packages) {\n    for (const [pkg, id] of Object.entries(overrides.packages)) {\n      if (!isValidNamedPackage(pkg)) {\n        throw new Error(`Invalid package name: ${pkg}`);\n      }\n      if (!isValidSuiAddress(normalizeSuiAddress(id))) {\n        throw new Error(`Invalid package ID: ${id}`);\n      }\n    }\n  }\n  if (overrides?.types) {\n    for (const [type, val] of Object.entries(overrides.types)) {\n      if (parseStructTag(type).typeParams.length > 0) {\n        throw new Error(\"Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.\");\n      }\n      const parsedValue = parseStructTag(val);\n      if (!isValidSuiAddress(parsedValue.address)) {\n        throw new Error(`Invalid type: ${val}`);\n      }\n    }\n  }\n}\nfunction extractMvrTypes(type, types = /* @__PURE__ */new Set()) {\n  if (typeof type === \"string\" && !hasMvrName(type)) return types;\n  const tag = isStructTag(type) ? type : parseStructTag(type);\n  if (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n  for (const param of tag.typeParams) {\n    extractMvrTypes(param, types);\n  }\n  return types;\n}\nfunction replaceMvrNames(tag, typeCache) {\n  const type = isStructTag(tag) ? tag : parseStructTag(tag);\n  const typeTag = `${type.address}::${type.module}::${type.name}`;\n  const cacheHit = typeCache[typeTag];\n  return normalizeStructTag({\n    ...type,\n    address: cacheHit ? cacheHit.split(\"::\")[0] : type.address,\n    typeParams: type.typeParams.map(param => replaceMvrNames(param, typeCache))\n  });\n}\nfunction hasMvrName(nameOrType) {\n  return nameOrType.includes(NAME_SEPARATOR) || nameOrType.includes(\"@\") || nameOrType.includes(\".sui\");\n}\nfunction isStructTag(type) {\n  return typeof type === \"object\" && \"address\" in type && \"module\" in type && \"name\" in type && \"typeParams\" in type;\n}\nfunction findNamesInTransaction(builder) {\n  const packages = /* @__PURE__ */new Set();\n  const types = /* @__PURE__ */new Set();\n  for (const command of builder.commands) {\n    switch (command.$kind) {\n      case \"MakeMoveVec\":\n        if (command.MakeMoveVec.type) {\n          getNamesFromTypeList([command.MakeMoveVec.type]).forEach(type => {\n            types.add(type);\n          });\n        }\n        break;\n      case \"MoveCall\":\n        const moveCall = command.MoveCall;\n        const pkg = moveCall.package.split(\"::\")[0];\n        if (hasMvrName(pkg)) {\n          if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n          packages.add(pkg);\n        }\n        getNamesFromTypeList(moveCall.typeArguments ?? []).forEach(type => {\n          types.add(type);\n        });\n        break;\n      default:\n        break;\n    }\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n}\nfunction replaceNames(builder, resolved) {\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      if (!hasMvrName(command.MakeMoveVec.type)) continue;\n      if (!resolved.types[command.MakeMoveVec.type]) throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n      command.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (hasMvrName(name) && !resolved.packages[name]) throw new Error(`No address found for package: ${name}`);\n    if (hasMvrName(name)) {\n      nameParts[0] = resolved.packages[name].package;\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!hasMvrName(types[i])) continue;\n      if (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n      types[i] = resolved.types[types[i]].type;\n    }\n    tx.typeArguments = types;\n  }\n}\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */new Set();\n  for (const type of types) {\n    if (hasMvrName(type)) {\n      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n      names.add(type);\n    }\n  }\n  return names;\n}\nexport { MvrClient, extractMvrTypes, findNamesInTransaction, hasMvrName, replaceNames };\n//# sourceMappingURL=mvr.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}