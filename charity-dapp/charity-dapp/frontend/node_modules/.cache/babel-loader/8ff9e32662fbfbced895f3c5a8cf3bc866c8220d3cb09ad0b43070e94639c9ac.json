{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _client, _contract, _network, _host, _path, _claimApi, _gasCoin, _hasSui, _ownedObjects, _ZkSendLink_instances, loadBagObject_fn, loadBag_fn, loadClaimedAssets_fn, createSponsoredTransaction_fn, executeSponsoredTransaction_fn, fetch_fn, listNonContractClaimableAssets_fn, createNonContractClaimTransaction_fn, loadOwnedObjects_fn;\nimport { bcs } from \"@mysten/sui/bcs\";\nimport { getFullnodeUrl, SuiClient } from \"@mysten/sui/client\";\nimport { Ed25519Keypair } from \"@mysten/sui/keypairs/ed25519\";\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { fromBase64, normalizeStructTag, normalizeSuiAddress, normalizeSuiObjectId, parseStructTag, SUI_TYPE_ARG, toBase64 } from \"@mysten/sui/utils\";\nimport { ZkSendLinkBuilder } from \"./builder.js\";\nimport { getAssetsFromTransaction, isOwner, ownedAfterChange } from \"./utils.js\";\nimport { getContractIds, ZkBag } from \"./zk-bag.js\";\nconst DEFAULT_ZK_SEND_LINK_OPTIONS = {\n  host: \"https://getstashed.com\",\n  path: \"/claim\",\n  network: \"mainnet\"\n};\nconst SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);\nconst SUI_COIN_OBJECT_TYPE = normalizeStructTag(\"0x2::coin::Coin<0x2::sui::SUI>\");\nconst _ZkSendLink = class _ZkSendLink {\n  constructor({\n    network = DEFAULT_ZK_SEND_LINK_OPTIONS.network,\n    client = new SuiClient({\n      url: getFullnodeUrl(network)\n    }),\n    keypair,\n    contract = getContractIds(network),\n    address,\n    host = DEFAULT_ZK_SEND_LINK_OPTIONS.host,\n    path = DEFAULT_ZK_SEND_LINK_OPTIONS.path,\n    claimApi = `${host}/api`,\n    isContractLink\n  }) {\n    __privateAdd(this, _ZkSendLink_instances);\n    __privateAdd(this, _client);\n    __privateAdd(this, _contract);\n    __privateAdd(this, _network);\n    __privateAdd(this, _host);\n    __privateAdd(this, _path);\n    __privateAdd(this, _claimApi);\n    // State for non-contract based links\n    __privateAdd(this, _gasCoin);\n    __privateAdd(this, _hasSui, false);\n    __privateAdd(this, _ownedObjects, []);\n    if (!keypair && !address) {\n      throw new Error(\"Either keypair or address must be provided\");\n    }\n    __privateSet(this, _client, client);\n    this.keypair = keypair;\n    this.address = address ?? keypair.toSuiAddress();\n    __privateSet(this, _claimApi, claimApi);\n    __privateSet(this, _network, network);\n    __privateSet(this, _host, host);\n    __privateSet(this, _path, path);\n    if (isContractLink) {\n      if (!contract) {\n        throw new Error(\"Contract options are required for contract based links\");\n      }\n      __privateSet(this, _contract, new ZkBag(contract.packageId, contract));\n    }\n  }\n  static async fromUrl(url, options = {}) {\n    const parsed = new URL(url);\n    const isContractLink = parsed.hash.startsWith(\"#$\");\n    const parsedNetwork = parsed.searchParams.get(\"network\") === \"testnet\" ? \"testnet\" : \"mainnet\";\n    const network = options.network ?? parsedNetwork;\n    let link;\n    if (isContractLink) {\n      const keypair = Ed25519Keypair.fromSecretKey(fromBase64(parsed.hash.slice(2)));\n      link = new _ZkSendLink({\n        ...options,\n        keypair,\n        network,\n        host: `${parsed.protocol}//${parsed.host}`,\n        path: parsed.pathname,\n        isContractLink: true\n      });\n    } else {\n      const keypair = Ed25519Keypair.fromSecretKey(fromBase64(isContractLink ? parsed.hash.slice(2) : parsed.hash.slice(1)));\n      link = new _ZkSendLink({\n        ...options,\n        keypair,\n        network,\n        host: `${parsed.protocol}//${parsed.host}`,\n        path: parsed.pathname,\n        isContractLink: false\n      });\n    }\n    await link.loadAssets();\n    return link;\n  }\n  static async fromAddress(address, options) {\n    const link = new _ZkSendLink({\n      ...options,\n      address,\n      isContractLink: true\n    });\n    await link.loadAssets();\n    return link;\n  }\n  async loadClaimedStatus() {\n    await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this, {\n      loadAssets: false\n    });\n  }\n  async loadAssets(options = {}) {\n    if (__privateGet(this, _contract)) {\n      await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this, options);\n    } else {\n      await __privateMethod(this, _ZkSendLink_instances, loadOwnedObjects_fn).call(this, options);\n    }\n  }\n  async claimAssets(address, {\n    reclaim,\n    sign\n  } = {}) {\n    if (!this.keypair && !sign) {\n      throw new Error(\"Cannot claim assets without links keypair\");\n    }\n    if (this.claimed) {\n      throw new Error(\"Assets have already been claimed\");\n    }\n    if (!this.assets) {\n      throw new Error(\"Link assets could not be loaded.  Link has not been indexed or has already been claimed\");\n    }\n    if (!__privateGet(this, _contract)) {\n      const bytes2 = await this.createClaimTransaction(address).build({\n        client: __privateGet(this, _client)\n      });\n      const signature2 = sign ? await sign(bytes2) : (await this.keypair.signTransaction(bytes2)).signature;\n      return __privateGet(this, _client).executeTransactionBlock({\n        transactionBlock: bytes2,\n        signature: signature2\n      });\n    }\n    if (!this.assets) {\n      await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this);\n    }\n    const tx = this.createClaimTransaction(address, {\n      reclaim\n    });\n    const sponsored = await __privateMethod(this, _ZkSendLink_instances, createSponsoredTransaction_fn).call(this, tx, address, reclaim ? address : this.keypair.toSuiAddress());\n    const bytes = fromBase64(sponsored.bytes);\n    const signature = sign ? await sign(bytes) : (await this.keypair.signTransaction(bytes)).signature;\n    const {\n      digest\n    } = await __privateMethod(this, _ZkSendLink_instances, executeSponsoredTransaction_fn).call(this, sponsored, signature);\n    const result = await __privateGet(this, _client).waitForTransaction({\n      digest,\n      options: {\n        showEffects: true\n      }\n    });\n    if (result.effects?.status.status !== \"success\") {\n      throw new Error(`Claim transaction failed: ${result.effects?.status.error ?? \"Unknown error\"}`);\n    }\n    return result;\n  }\n  createClaimTransaction(address, {\n    reclaim\n  } = {}) {\n    if (!__privateGet(this, _contract)) {\n      return __privateMethod(this, _ZkSendLink_instances, createNonContractClaimTransaction_fn).call(this, address);\n    }\n    if (!this.keypair && !reclaim) {\n      throw new Error(\"Cannot claim assets without the links keypair\");\n    }\n    const tx = new Transaction();\n    const sender = reclaim ? address : this.keypair.toSuiAddress();\n    tx.setSender(sender);\n    const store = tx.object(__privateGet(this, _contract).ids.bagStoreId);\n    const command = reclaim ? __privateGet(this, _contract).reclaim({\n      arguments: [store, this.address]\n    }) : __privateGet(this, _contract).init_claim({\n      arguments: [store]\n    });\n    const [bag, proof] = tx.add(command);\n    const objectsToTransfer = [];\n    const objects = [...(this.assets?.coins ?? []), ...(this.assets?.nfts ?? [])];\n    for (const object of objects) {\n      objectsToTransfer.push(__privateGet(this, _contract).claim({\n        arguments: [bag, proof, tx.receivingRef({\n          objectId: object.objectId,\n          version: object.version,\n          digest: object.digest\n        })],\n        typeArguments: [object.type]\n      }));\n    }\n    if (objectsToTransfer.length > 0) {\n      tx.transferObjects(objectsToTransfer, address);\n    }\n    tx.add(__privateGet(this, _contract).finalize({\n      arguments: [bag, proof]\n    }));\n    return tx;\n  }\n  async createRegenerateTransaction(sender, options = {}) {\n    if (!this.assets) {\n      await __privateMethod(this, _ZkSendLink_instances, loadBag_fn).call(this);\n    }\n    if (this.claimed) {\n      throw new Error(\"Assets have already been claimed\");\n    }\n    if (!__privateGet(this, _contract)) {\n      throw new Error(\"Regenerating non-contract based links is not supported\");\n    }\n    const tx = new Transaction();\n    tx.setSender(sender);\n    const store = tx.object(__privateGet(this, _contract).ids.bagStoreId);\n    const newLinkKp = Ed25519Keypair.generate();\n    const newLink = new ZkSendLinkBuilder({\n      ...options,\n      sender,\n      client: __privateGet(this, _client),\n      contract: __privateGet(this, _contract).ids,\n      host: __privateGet(this, _host),\n      path: __privateGet(this, _path),\n      keypair: newLinkKp\n    });\n    const to = tx.pure.address(newLinkKp.toSuiAddress());\n    tx.add(__privateGet(this, _contract).update_receiver({\n      arguments: [store, this.address, to]\n    }));\n    return {\n      url: newLink.getLink(),\n      transaction: tx\n    };\n  }\n};\n_client = new WeakMap();\n_contract = new WeakMap();\n_network = new WeakMap();\n_host = new WeakMap();\n_path = new WeakMap();\n_claimApi = new WeakMap();\n_gasCoin = new WeakMap();\n_hasSui = new WeakMap();\n_ownedObjects = new WeakMap();\n_ZkSendLink_instances = new WeakSet();\nloadBagObject_fn = async function () {\n  if (!__privateGet(this, _contract)) {\n    throw new Error(\"Cannot load bag object for non-contract based links\");\n  }\n  const bagField = await __privateGet(this, _client).getDynamicFieldObject({\n    parentId: __privateGet(this, _contract).ids.bagStoreTableId,\n    name: {\n      type: \"address\",\n      value: this.address\n    }\n  });\n  this.bagObject = bagField.data;\n  if (this.bagObject) {\n    this.claimed = false;\n  }\n};\nloadBag_fn = async function ({\n  transaction,\n  loadAssets = true,\n  loadClaimedAssets = loadAssets\n} = {}) {\n  if (!__privateGet(this, _contract)) {\n    return;\n  }\n  if (!this.bagObject || !this.claimed) {\n    await __privateMethod(this, _ZkSendLink_instances, loadBagObject_fn).call(this);\n  }\n  if (!loadAssets) {\n    return;\n  }\n  if (!this.bagObject) {\n    if (loadClaimedAssets) {\n      await __privateMethod(this, _ZkSendLink_instances, loadClaimedAssets_fn).call(this);\n    }\n    return;\n  }\n  const bagId = this.bagObject.content.fields.value.fields?.id?.id;\n  if (bagId && transaction?.balanceChanges && transaction.objectChanges) {\n    this.assets = getAssetsFromTransaction({\n      transaction,\n      address: bagId,\n      isSent: false\n    });\n    return;\n  }\n  const itemIds = this.bagObject?.content?.fields?.value?.fields?.item_ids.fields.contents;\n  this.creatorAddress = this.bagObject?.content?.fields?.value?.fields?.owner;\n  if (!itemIds) {\n    throw new Error(\"Invalid bag field\");\n  }\n  const objectsResponse = await __privateGet(this, _client).multiGetObjects({\n    ids: itemIds,\n    options: {\n      showType: true,\n      showContent: true\n    }\n  });\n  this.assets = {\n    balances: [],\n    nfts: [],\n    coins: []\n  };\n  const balances = /* @__PURE__ */new Map();\n  objectsResponse.forEach((object, i) => {\n    if (!object.data || !object.data.type) {\n      throw new Error(`Failed to load claimable object ${itemIds[i]}`);\n    }\n    const type = parseStructTag(normalizeStructTag(object.data.type));\n    if (type.address === normalizeSuiAddress(\"0x2\") && type.module === \"coin\" && type.name === \"Coin\") {\n      this.assets.coins.push({\n        objectId: object.data.objectId,\n        type: object.data.type,\n        version: object.data.version,\n        digest: object.data.digest\n      });\n      if (object.data.content?.dataType === \"moveObject\") {\n        const amount = BigInt(object.data.content.fields.balance);\n        const coinType = normalizeStructTag(parseStructTag(object.data.content.type).typeParams[0]);\n        if (!balances.has(coinType)) {\n          balances.set(coinType, {\n            coinType,\n            amount\n          });\n        } else {\n          balances.get(coinType).amount += amount;\n        }\n      }\n    } else {\n      this.assets.nfts.push({\n        objectId: object.data.objectId,\n        type: object.data.type,\n        version: object.data.version,\n        digest: object.data.digest\n      });\n    }\n  });\n  this.assets.balances = [...balances.values()];\n};\nloadClaimedAssets_fn = async function () {\n  const result = await __privateGet(this, _client).queryTransactionBlocks({\n    limit: 1,\n    filter: {\n      FromAddress: this.address\n    },\n    options: {\n      showObjectChanges: true,\n      showBalanceChanges: true,\n      showInput: true\n    }\n  });\n  if (!result?.data[0]) {\n    return;\n  }\n  const [tx] = result.data;\n  if (tx.transaction?.data.transaction.kind !== \"ProgrammableTransaction\") {\n    return;\n  }\n  const transfer = tx.transaction.data.transaction.transactions.findLast(tx2 => \"TransferObjects\" in tx2);\n  if (!transfer) {\n    return;\n  }\n  const receiverArg = transfer.TransferObjects[1];\n  if (!(typeof receiverArg === \"object\" && \"Input\" in receiverArg)) {\n    return;\n  }\n  const input = tx.transaction.data.transaction.inputs[receiverArg.Input];\n  if (input.type !== \"pure\") {\n    return;\n  }\n  const receiver = typeof input.value === \"string\" ? input.value : bcs.Address.parse(new Uint8Array(input.value.Pure));\n  this.claimed = true;\n  this.claimedBy = receiver;\n  this.assets = getAssetsFromTransaction({\n    transaction: tx,\n    address: receiver,\n    isSent: false\n  });\n};\ncreateSponsoredTransaction_fn = async function (tx, claimer, sender) {\n  return __privateMethod(this, _ZkSendLink_instances, fetch_fn).call(this, \"transaction-blocks/sponsor\", {\n    method: \"POST\",\n    body: JSON.stringify({\n      network: __privateGet(this, _network),\n      sender,\n      claimer,\n      transactionBlockKindBytes: toBase64(await tx.build({\n        onlyTransactionKind: true,\n        client: __privateGet(this, _client)\n      }))\n    })\n  });\n};\nexecuteSponsoredTransaction_fn = async function (input, signature) {\n  return __privateMethod(this, _ZkSendLink_instances, fetch_fn).call(this, `transaction-blocks/sponsor/${input.digest}`, {\n    method: \"POST\",\n    body: JSON.stringify({\n      signature\n    })\n  });\n};\nfetch_fn = async function (path, init) {\n  const res = await fetch(`${__privateGet(this, _claimApi)}/v1/${path}`, {\n    ...init,\n    headers: {\n      ...init.headers,\n      \"Content-Type\": \"application/json\"\n    }\n  });\n  if (!res.ok) {\n    console.error(path, await res.text());\n    throw new Error(`Request to claim API failed with status code ${res.status}`);\n  }\n  const {\n    data\n  } = await res.json();\n  return data;\n};\nlistNonContractClaimableAssets_fn = async function () {\n  const balances = [];\n  const nfts = [];\n  const coins = [];\n  if (__privateGet(this, _ownedObjects).length === 0 && !__privateGet(this, _hasSui)) {\n    return {\n      balances,\n      nfts,\n      coins\n    };\n  }\n  const address = new Ed25519Keypair().toSuiAddress();\n  const normalizedAddress = normalizeSuiAddress(address);\n  const tx = this.createClaimTransaction(normalizedAddress);\n  if (__privateGet(this, _gasCoin) || !__privateGet(this, _hasSui)) {\n    tx.setGasPayment([]);\n  }\n  const dryRun = await __privateGet(this, _client).dryRunTransactionBlock({\n    transactionBlock: await tx.build({\n      client: __privateGet(this, _client)\n    })\n  });\n  dryRun.balanceChanges.forEach(balanceChange => {\n    if (BigInt(balanceChange.amount) > 0n && isOwner(balanceChange.owner, normalizedAddress)) {\n      balances.push({\n        coinType: normalizeStructTag(balanceChange.coinType),\n        amount: BigInt(balanceChange.amount)\n      });\n    }\n  });\n  dryRun.objectChanges.forEach(objectChange => {\n    if (\"objectType\" in objectChange) {\n      const type = parseStructTag(objectChange.objectType);\n      if (type.address === normalizeSuiAddress(\"0x2\") && type.module === \"coin\" && type.name === \"Coin\") {\n        if (ownedAfterChange(objectChange, normalizedAddress)) {\n          coins.push(objectChange);\n        }\n        return;\n      }\n    }\n    if (ownedAfterChange(objectChange, normalizedAddress)) {\n      nfts.push(objectChange);\n    }\n  });\n  return {\n    balances,\n    nfts,\n    coins\n  };\n};\ncreateNonContractClaimTransaction_fn = function (address) {\n  if (!this.keypair) {\n    throw new Error(\"Cannot claim assets without the links keypair\");\n  }\n  const tx = new Transaction();\n  tx.setSender(this.keypair.toSuiAddress());\n  const objectsToTransfer = __privateGet(this, _ownedObjects).filter(object => {\n    if (__privateGet(this, _gasCoin)) {\n      if (object.objectId === __privateGet(this, _gasCoin).coinObjectId) {\n        return false;\n      }\n    } else if (object.type === SUI_COIN_OBJECT_TYPE) {\n      return false;\n    }\n    return true;\n  }).map(object => tx.object(object.objectId));\n  if (__privateGet(this, _gasCoin) && this.creatorAddress) {\n    tx.transferObjects([tx.gas], this.creatorAddress);\n  } else {\n    objectsToTransfer.push(tx.gas);\n  }\n  if (objectsToTransfer.length > 0) {\n    tx.transferObjects(objectsToTransfer, address);\n  }\n  return tx;\n};\nloadOwnedObjects_fn = async function ({\n  loadClaimedAssets = true\n} = {}) {\n  this.assets = {\n    nfts: [],\n    balances: [],\n    coins: []\n  };\n  let nextCursor;\n  do {\n    const ownedObjects = await __privateGet(this, _client).getOwnedObjects({\n      cursor: nextCursor,\n      owner: this.address,\n      options: {\n        showType: true,\n        showContent: true\n      }\n    });\n    nextCursor = ownedObjects.hasNextPage ? ownedObjects.nextCursor : null;\n    for (const object of ownedObjects.data) {\n      if (object.data) {\n        __privateGet(this, _ownedObjects).push({\n          objectId: normalizeSuiObjectId(object.data.objectId),\n          version: object.data.version,\n          digest: object.data.digest,\n          type: normalizeStructTag(object.data.type)\n        });\n      }\n    }\n  } while (nextCursor);\n  const coins = await __privateGet(this, _client).getCoins({\n    coinType: SUI_COIN_TYPE,\n    owner: this.address\n  });\n  __privateSet(this, _hasSui, coins.data.length > 0);\n  __privateSet(this, _gasCoin, coins.data.find(coin => BigInt(coin.balance) % 1000n === 987n));\n  const result = await __privateGet(this, _client).queryTransactionBlocks({\n    limit: 1,\n    order: \"ascending\",\n    filter: {\n      ToAddress: this.address\n    },\n    options: {\n      showInput: true,\n      showBalanceChanges: true,\n      showObjectChanges: true\n    }\n  });\n  this.creatorAddress = result.data[0]?.transaction?.data.sender;\n  if (__privateGet(this, _hasSui) || __privateGet(this, _ownedObjects).length > 0) {\n    this.claimed = false;\n    this.assets = await __privateMethod(this, _ZkSendLink_instances, listNonContractClaimableAssets_fn).call(this);\n  } else if (result.data[0] && loadClaimedAssets) {\n    this.claimed = true;\n    await __privateMethod(this, _ZkSendLink_instances, loadClaimedAssets_fn).call(this);\n  }\n};\nlet ZkSendLink = _ZkSendLink;\nexport { ZkSendLink };\n//# sourceMappingURL=claim.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}