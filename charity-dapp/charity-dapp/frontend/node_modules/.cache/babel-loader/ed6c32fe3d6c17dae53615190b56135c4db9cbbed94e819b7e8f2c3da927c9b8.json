{"ast":null,"code":"import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport { array, bigint, boolean, check, integer, is, lazy, literal, nullable, nullish, number, object, optional, parse, pipe, string, union, unknown } from \"valibot\";\nimport { TypeTagSerializer } from \"../../bcs/index.js\";\nimport { JsonU64, ObjectID, safeEnum, TransactionDataSchema } from \"./internal.js\";\nconst ObjectRef = object({\n  digest: string(),\n  objectId: string(),\n  version: union([pipe(number(), integer()), string(), bigint()])\n});\nconst ObjectArg = safeEnum({\n  ImmOrOwned: ObjectRef,\n  Shared: object({\n    objectId: ObjectID,\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRef\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArg,\n  Pure: array(pipe(number(), integer()))\n});\nconst TransactionInput = union([object({\n  kind: literal(\"Input\"),\n  index: pipe(number(), integer()),\n  value: unknown(),\n  type: optional(literal(\"object\"))\n}), object({\n  kind: literal(\"Input\"),\n  index: pipe(number(), integer()),\n  value: unknown(),\n  type: literal(\"pure\")\n})]);\nconst TransactionExpiration = union([object({\n  Epoch: pipe(number(), integer())\n}), object({\n  None: nullable(literal(true))\n})]);\nconst StringEncodedBigint = pipe(union([number(), string(), bigint()]), check(val => {\n  if (![\"string\", \"number\", \"bigint\"].includes(typeof val)) return false;\n  try {\n    BigInt(val);\n    return true;\n  } catch {\n    return false;\n  }\n}));\nconst TypeTag = union([object({\n  bool: nullable(literal(true))\n}), object({\n  u8: nullable(literal(true))\n}), object({\n  u64: nullable(literal(true))\n}), object({\n  u128: nullable(literal(true))\n}), object({\n  address: nullable(literal(true))\n}), object({\n  signer: nullable(literal(true))\n}), object({\n  vector: lazy(() => TypeTag)\n}), object({\n  struct: lazy(() => StructTag)\n}), object({\n  u16: nullable(literal(true))\n}), object({\n  u32: nullable(literal(true))\n}), object({\n  u256: nullable(literal(true))\n})]);\nconst StructTag = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  typeParams: array(TypeTag)\n});\nconst GasConfig = object({\n  budget: optional(StringEncodedBigint),\n  price: optional(StringEncodedBigint),\n  payment: optional(array(ObjectRef)),\n  owner: optional(string())\n});\nconst TransactionArgumentTypes = [TransactionInput, object({\n  kind: literal(\"GasCoin\")\n}), object({\n  kind: literal(\"Result\"),\n  index: pipe(number(), integer())\n}), object({\n  kind: literal(\"NestedResult\"),\n  index: pipe(number(), integer()),\n  resultIndex: pipe(number(), integer())\n})];\nconst TransactionArgument = union([...TransactionArgumentTypes]);\nconst MoveCallTransaction = object({\n  kind: literal(\"MoveCall\"),\n  target: pipe(string(), check(target => target.split(\"::\").length === 3)),\n  typeArguments: array(string()),\n  arguments: array(TransactionArgument)\n});\nconst TransferObjectsTransaction = object({\n  kind: literal(\"TransferObjects\"),\n  objects: array(TransactionArgument),\n  address: TransactionArgument\n});\nconst SplitCoinsTransaction = object({\n  kind: literal(\"SplitCoins\"),\n  coin: TransactionArgument,\n  amounts: array(TransactionArgument)\n});\nconst MergeCoinsTransaction = object({\n  kind: literal(\"MergeCoins\"),\n  destination: TransactionArgument,\n  sources: array(TransactionArgument)\n});\nconst MakeMoveVecTransaction = object({\n  kind: literal(\"MakeMoveVec\"),\n  type: union([object({\n    Some: TypeTag\n  }), object({\n    None: nullable(literal(true))\n  })]),\n  objects: array(TransactionArgument)\n});\nconst PublishTransaction = object({\n  kind: literal(\"Publish\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string())\n});\nconst UpgradeTransaction = object({\n  kind: literal(\"Upgrade\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string()),\n  packageId: string(),\n  ticket: TransactionArgument\n});\nconst TransactionTypes = [MoveCallTransaction, TransferObjectsTransaction, SplitCoinsTransaction, MergeCoinsTransaction, PublishTransaction, UpgradeTransaction, MakeMoveVecTransaction];\nconst TransactionType = union([...TransactionTypes]);\nconst SerializedTransactionDataV1 = object({\n  version: literal(1),\n  sender: optional(string()),\n  expiration: nullish(TransactionExpiration),\n  gasConfig: GasConfig,\n  inputs: array(TransactionInput),\n  transactions: array(TransactionType)\n});\nfunction serializeV1TransactionData(transactionData) {\n  const inputs = transactionData.inputs.map((input, index) => {\n    if (input.Object) {\n      return {\n        kind: \"Input\",\n        index,\n        value: {\n          Object: input.Object.ImmOrOwnedObject ? {\n            ImmOrOwned: input.Object.ImmOrOwnedObject\n          } : input.Object.Receiving ? {\n            Receiving: {\n              digest: input.Object.Receiving.digest,\n              version: input.Object.Receiving.version,\n              objectId: input.Object.Receiving.objectId\n            }\n          } : {\n            Shared: {\n              mutable: input.Object.SharedObject.mutable,\n              initialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n              objectId: input.Object.SharedObject.objectId\n            }\n          }\n        },\n        type: \"object\"\n      };\n    }\n    if (input.Pure) {\n      return {\n        kind: \"Input\",\n        index,\n        value: {\n          Pure: Array.from(fromBase64(input.Pure.bytes))\n        },\n        type: \"pure\"\n      };\n    }\n    if (input.UnresolvedPure) {\n      return {\n        kind: \"Input\",\n        type: \"pure\",\n        index,\n        value: input.UnresolvedPure.value\n      };\n    }\n    if (input.UnresolvedObject) {\n      return {\n        kind: \"Input\",\n        type: \"object\",\n        index,\n        value: input.UnresolvedObject.objectId\n      };\n    }\n    throw new Error(\"Invalid input\");\n  });\n  return {\n    version: 1,\n    sender: transactionData.sender ?? void 0,\n    expiration: transactionData.expiration?.$kind === \"Epoch\" ? {\n      Epoch: Number(transactionData.expiration.Epoch)\n    } : transactionData.expiration ? {\n      None: true\n    } : null,\n    gasConfig: {\n      owner: transactionData.gasData.owner ?? void 0,\n      budget: transactionData.gasData.budget ?? void 0,\n      price: transactionData.gasData.price ?? void 0,\n      payment: transactionData.gasData.payment ?? void 0\n    },\n    inputs,\n    transactions: transactionData.commands.map(command => {\n      if (command.MakeMoveVec) {\n        return {\n          kind: \"MakeMoveVec\",\n          type: command.MakeMoveVec.type === null ? {\n            None: true\n          } : {\n            Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type)\n          },\n          objects: command.MakeMoveVec.elements.map(arg => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.MergeCoins) {\n        return {\n          kind: \"MergeCoins\",\n          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n          sources: command.MergeCoins.sources.map(arg => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.MoveCall) {\n        return {\n          kind: \"MoveCall\",\n          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n          typeArguments: command.MoveCall.typeArguments,\n          arguments: command.MoveCall.arguments.map(arg => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.Publish) {\n        return {\n          kind: \"Publish\",\n          modules: command.Publish.modules.map(mod => Array.from(fromBase64(mod))),\n          dependencies: command.Publish.dependencies\n        };\n      }\n      if (command.SplitCoins) {\n        return {\n          kind: \"SplitCoins\",\n          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n          amounts: command.SplitCoins.amounts.map(arg => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.TransferObjects) {\n        return {\n          kind: \"TransferObjects\",\n          objects: command.TransferObjects.objects.map(arg => convertTransactionArgument(arg, inputs)),\n          address: convertTransactionArgument(command.TransferObjects.address, inputs)\n        };\n      }\n      if (command.Upgrade) {\n        return {\n          kind: \"Upgrade\",\n          modules: command.Upgrade.modules.map(mod => Array.from(fromBase64(mod))),\n          dependencies: command.Upgrade.dependencies,\n          packageId: command.Upgrade.package,\n          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)\n        };\n      }\n      throw new Error(`Unknown transaction ${Object.keys(command)}`);\n    })\n  };\n}\nfunction convertTransactionArgument(arg, inputs) {\n  if (arg.$kind === \"GasCoin\") {\n    return {\n      kind: \"GasCoin\"\n    };\n  }\n  if (arg.$kind === \"Result\") {\n    return {\n      kind: \"Result\",\n      index: arg.Result\n    };\n  }\n  if (arg.$kind === \"NestedResult\") {\n    return {\n      kind: \"NestedResult\",\n      index: arg.NestedResult[0],\n      resultIndex: arg.NestedResult[1]\n    };\n  }\n  if (arg.$kind === \"Input\") {\n    return inputs[arg.Input];\n  }\n  throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\nfunction transactionDataFromV1(data) {\n  return parse(TransactionDataSchema, {\n    version: 2,\n    sender: data.sender ?? null,\n    expiration: data.expiration ? \"Epoch\" in data.expiration ? {\n      Epoch: data.expiration.Epoch\n    } : {\n      None: true\n    } : null,\n    gasData: {\n      owner: data.gasConfig.owner ?? null,\n      budget: data.gasConfig.budget?.toString() ?? null,\n      price: data.gasConfig.price?.toString() ?? null,\n      payment: data.gasConfig.payment?.map(ref => ({\n        digest: ref.digest,\n        objectId: ref.objectId,\n        version: ref.version.toString()\n      })) ?? null\n    },\n    inputs: data.inputs.map(input => {\n      if (input.kind === \"Input\") {\n        if (is(NormalizedCallArg, input.value)) {\n          const value = parse(NormalizedCallArg, input.value);\n          if (value.Object) {\n            if (value.Object.ImmOrOwned) {\n              return {\n                Object: {\n                  ImmOrOwnedObject: {\n                    objectId: value.Object.ImmOrOwned.objectId,\n                    version: String(value.Object.ImmOrOwned.version),\n                    digest: value.Object.ImmOrOwned.digest\n                  }\n                }\n              };\n            }\n            if (value.Object.Shared) {\n              return {\n                Object: {\n                  SharedObject: {\n                    mutable: value.Object.Shared.mutable ?? null,\n                    initialSharedVersion: value.Object.Shared.initialSharedVersion,\n                    objectId: value.Object.Shared.objectId\n                  }\n                }\n              };\n            }\n            if (value.Object.Receiving) {\n              return {\n                Object: {\n                  Receiving: {\n                    digest: value.Object.Receiving.digest,\n                    version: String(value.Object.Receiving.version),\n                    objectId: value.Object.Receiving.objectId\n                  }\n                }\n              };\n            }\n            throw new Error(\"Invalid object input\");\n          }\n          return {\n            Pure: {\n              bytes: toBase64(new Uint8Array(value.Pure))\n            }\n          };\n        }\n        if (input.type === \"object\") {\n          return {\n            UnresolvedObject: {\n              objectId: input.value\n            }\n          };\n        }\n        return {\n          UnresolvedPure: {\n            value: input.value\n          }\n        };\n      }\n      throw new Error(\"Invalid input\");\n    }),\n    commands: data.transactions.map(transaction => {\n      switch (transaction.kind) {\n        case \"MakeMoveVec\":\n          return {\n            MakeMoveVec: {\n              type: \"Some\" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,\n              elements: transaction.objects.map(arg => parseV1TransactionArgument(arg))\n            }\n          };\n        case \"MergeCoins\":\n          {\n            return {\n              MergeCoins: {\n                destination: parseV1TransactionArgument(transaction.destination),\n                sources: transaction.sources.map(arg => parseV1TransactionArgument(arg))\n              }\n            };\n          }\n        case \"MoveCall\":\n          {\n            const [pkg, mod, fn] = transaction.target.split(\"::\");\n            return {\n              MoveCall: {\n                package: pkg,\n                module: mod,\n                function: fn,\n                typeArguments: transaction.typeArguments,\n                arguments: transaction.arguments.map(arg => parseV1TransactionArgument(arg))\n              }\n            };\n          }\n        case \"Publish\":\n          {\n            return {\n              Publish: {\n                modules: transaction.modules.map(mod => toBase64(Uint8Array.from(mod))),\n                dependencies: transaction.dependencies\n              }\n            };\n          }\n        case \"SplitCoins\":\n          {\n            return {\n              SplitCoins: {\n                coin: parseV1TransactionArgument(transaction.coin),\n                amounts: transaction.amounts.map(arg => parseV1TransactionArgument(arg))\n              }\n            };\n          }\n        case \"TransferObjects\":\n          {\n            return {\n              TransferObjects: {\n                objects: transaction.objects.map(arg => parseV1TransactionArgument(arg)),\n                address: parseV1TransactionArgument(transaction.address)\n              }\n            };\n          }\n        case \"Upgrade\":\n          {\n            return {\n              Upgrade: {\n                modules: transaction.modules.map(mod => toBase64(Uint8Array.from(mod))),\n                dependencies: transaction.dependencies,\n                package: transaction.packageId,\n                ticket: parseV1TransactionArgument(transaction.ticket)\n              }\n            };\n          }\n      }\n      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n    })\n  });\n}\nfunction parseV1TransactionArgument(arg) {\n  switch (arg.kind) {\n    case \"GasCoin\":\n      {\n        return {\n          GasCoin: true\n        };\n      }\n    case \"Result\":\n      return {\n        Result: arg.index\n      };\n    case \"NestedResult\":\n      {\n        return {\n          NestedResult: [arg.index, arg.resultIndex]\n        };\n      }\n    case \"Input\":\n      {\n        return {\n          Input: arg.index\n        };\n      }\n  }\n}\nexport { NormalizedCallArg, ObjectRef, SerializedTransactionDataV1, StructTag, TransactionArgument, TypeTag, serializeV1TransactionData, transactionDataFromV1 };\n//# sourceMappingURL=v1.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}