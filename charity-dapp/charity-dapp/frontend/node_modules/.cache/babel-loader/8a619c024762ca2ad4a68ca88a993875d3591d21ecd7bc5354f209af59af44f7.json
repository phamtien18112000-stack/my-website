{"ast":null,"code":"import { Inputs } from \"./Inputs.js\";\nimport { bcs } from \"../bcs/index.js\";\nimport { jsonRpcClientResolveTransactionPlugin } from \"../jsonRpc/json-rpc-resolver.js\";\nfunction needsTransactionResolution(data, options) {\n  if (data.inputs.some(input => {\n    return input.UnresolvedObject || input.UnresolvedPure;\n  })) {\n    return true;\n  }\n  if (!options.onlyTransactionKind) {\n    if (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n      return true;\n    }\n  }\n  return false;\n}\nasync function resolveTransactionPlugin(transactionData, options, next) {\n  normalizeRawArguments(transactionData);\n  if (!needsTransactionResolution(transactionData, options)) {\n    await validate(transactionData);\n    return next();\n  }\n  const client = getClient(options);\n  const plugin = client.core?.resolveTransactionPlugin() ?? jsonRpcClientResolveTransactionPlugin(client);\n  return plugin(transactionData, options, async () => {\n    await validate(transactionData);\n    await next();\n  });\n}\nfunction validate(transactionData) {\n  transactionData.inputs.forEach((input, index) => {\n    if (input.$kind !== \"Object\" && input.$kind !== \"Pure\") {\n      throw new Error(`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(input)}`);\n    }\n  });\n}\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`);\n  }\n  return options.client;\n}\nfunction normalizeRawArguments(transactionData) {\n  for (const command of transactionData.commands) {\n    switch (command.$kind) {\n      case \"SplitCoins\":\n        command.SplitCoins.amounts.forEach(amount => {\n          normalizeRawArgument(amount, bcs.U64, transactionData);\n        });\n        break;\n      case \"TransferObjects\":\n        normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n        break;\n    }\n  }\n}\nfunction normalizeRawArgument(arg, schema, transactionData) {\n  if (arg.$kind !== \"Input\") {\n    return;\n  }\n  const input = transactionData.inputs[arg.Input];\n  if (input.$kind !== \"UnresolvedPure\") {\n    return;\n  }\n  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\nexport { getClient, needsTransactionResolution, resolveTransactionPlugin };\n//# sourceMappingURL=resolve.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}