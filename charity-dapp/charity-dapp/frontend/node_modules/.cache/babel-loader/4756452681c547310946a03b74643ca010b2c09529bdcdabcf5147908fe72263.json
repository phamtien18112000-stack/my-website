{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar _signer, _client, _coinBatchSize, _initialCoinBalance, _minimumCoinBalance, _epochBoundaryWindow, _defaultGasBudget, _maxPoolSize, _sourceCoins, _coinPool, _cache, _objectIdQueues, _buildQueue, _executeQueue, _lastDigest, _cacheLock, _pendingTransactions, _gasPrice, _ParallelTransactionExecutor_instances, getUsedObjects_fn, execute_fn, updateCache_fn, waitForLastDigest_fn, getGasCoin_fn, getGasPrice_fn, refillCoinPool_fn;\nimport { toBase64 } from \"@mysten/bcs\";\nimport { promiseWithResolvers } from \"@mysten/utils\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { Transaction } from \"../Transaction.js\";\nimport { TransactionDataBuilder } from \"../TransactionData.js\";\nimport { CachingTransactionExecutor } from \"./caching.js\";\nimport { ParallelQueue, SerialQueue } from \"./queue.js\";\nimport { getGasCoinFromEffects } from \"./serial.js\";\nconst PARALLEL_EXECUTOR_DEFAULTS = {\n  coinBatchSize: 20,\n  initialCoinBalance: 200000000n,\n  minimumCoinBalance: 50000000n,\n  maxPoolSize: 50,\n  epochBoundaryWindow: 1e3\n};\nclass ParallelTransactionExecutor {\n  constructor(options) {\n    __privateAdd(this, _ParallelTransactionExecutor_instances);\n    __privateAdd(this, _signer);\n    __privateAdd(this, _client);\n    __privateAdd(this, _coinBatchSize);\n    __privateAdd(this, _initialCoinBalance);\n    __privateAdd(this, _minimumCoinBalance);\n    __privateAdd(this, _epochBoundaryWindow);\n    __privateAdd(this, _defaultGasBudget);\n    __privateAdd(this, _maxPoolSize);\n    __privateAdd(this, _sourceCoins);\n    __privateAdd(this, _coinPool, []);\n    __privateAdd(this, _cache);\n    __privateAdd(this, _objectIdQueues, /* @__PURE__ */new Map());\n    __privateAdd(this, _buildQueue, new SerialQueue());\n    __privateAdd(this, _executeQueue);\n    __privateAdd(this, _lastDigest, null);\n    __privateAdd(this, _cacheLock, null);\n    __privateAdd(this, _pendingTransactions, 0);\n    __privateAdd(this, _gasPrice, null);\n    __privateSet(this, _signer, options.signer);\n    __privateSet(this, _client, options.client);\n    __privateSet(this, _coinBatchSize, options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize);\n    __privateSet(this, _initialCoinBalance, options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance);\n    __privateSet(this, _minimumCoinBalance, options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance);\n    __privateSet(this, _defaultGasBudget, options.defaultGasBudget ?? __privateGet(this, _minimumCoinBalance));\n    __privateSet(this, _epochBoundaryWindow, options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow);\n    __privateSet(this, _maxPoolSize, options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize);\n    __privateSet(this, _cache, new CachingTransactionExecutor({\n      client: options.client,\n      cache: options.cache\n    }));\n    __privateSet(this, _executeQueue, new ParallelQueue(__privateGet(this, _maxPoolSize)));\n    __privateSet(this, _sourceCoins, options.sourceCoins ? new Map(options.sourceCoins.map(id => [id, null])) : null);\n  }\n  resetCache() {\n    __privateSet(this, _gasPrice, null);\n    return __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateGet(this, _cache).reset());\n  }\n  async waitForLastTransaction() {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this));\n  }\n  async executeTransaction(transaction, options, additionalSignatures = []) {\n    const {\n      promise,\n      resolve,\n      reject\n    } = promiseWithResolvers();\n    const usedObjects = await __privateMethod(this, _ParallelTransactionExecutor_instances, getUsedObjects_fn).call(this, transaction);\n    const execute = () => {\n      __privateGet(this, _executeQueue).runTask(() => {\n        const promise2 = __privateMethod(this, _ParallelTransactionExecutor_instances, execute_fn).call(this, transaction, usedObjects, options, additionalSignatures);\n        return promise2.then(resolve, reject);\n      });\n    };\n    const conflicts = /* @__PURE__ */new Set();\n    usedObjects.forEach(objectId => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue) {\n        conflicts.add(objectId);\n        __privateGet(this, _objectIdQueues).get(objectId).push(() => {\n          conflicts.delete(objectId);\n          if (conflicts.size === 0) {\n            execute();\n          }\n        });\n      } else {\n        __privateGet(this, _objectIdQueues).set(objectId, []);\n      }\n    });\n    if (conflicts.size === 0) {\n      execute();\n    }\n    return promise;\n  }\n}\n_signer = new WeakMap();\n_client = new WeakMap();\n_coinBatchSize = new WeakMap();\n_initialCoinBalance = new WeakMap();\n_minimumCoinBalance = new WeakMap();\n_epochBoundaryWindow = new WeakMap();\n_defaultGasBudget = new WeakMap();\n_maxPoolSize = new WeakMap();\n_sourceCoins = new WeakMap();\n_coinPool = new WeakMap();\n_cache = new WeakMap();\n_objectIdQueues = new WeakMap();\n_buildQueue = new WeakMap();\n_executeQueue = new WeakMap();\n_lastDigest = new WeakMap();\n_cacheLock = new WeakMap();\n_pendingTransactions = new WeakMap();\n_gasPrice = new WeakMap();\n_ParallelTransactionExecutor_instances = new WeakSet();\ngetUsedObjects_fn = async function (transaction) {\n  const usedObjects = /* @__PURE__ */new Set();\n  let serialized = false;\n  transaction.addSerializationPlugin(async (blockData, _options, next) => {\n    await next();\n    if (serialized) {\n      return;\n    }\n    serialized = true;\n    blockData.inputs.forEach(input => {\n      if (input.Object?.ImmOrOwnedObject?.objectId) {\n        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);\n      } else if (input.Object?.Receiving?.objectId) {\n        usedObjects.add(input.Object.Receiving.objectId);\n      } else if (input.UnresolvedObject?.objectId && !input.UnresolvedObject.initialSharedVersion) {\n        usedObjects.add(input.UnresolvedObject.objectId);\n      }\n    });\n  });\n  await transaction.prepareForSerialization({\n    client: __privateGet(this, _client)\n  });\n  return usedObjects;\n};\nexecute_fn = async function (transaction, usedObjects, options, additionalSignatures = []) {\n  let gasCoin;\n  try {\n    transaction.setSenderIfNotSet(__privateGet(this, _signer).toSuiAddress());\n    await __privateGet(this, _buildQueue).runTask(async () => {\n      const data = transaction.getData();\n      if (!data.gasData.price) {\n        transaction.setGasPrice(await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));\n      }\n      transaction.setGasBudgetIfNotSet(__privateGet(this, _defaultGasBudget));\n      await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);\n      gasCoin = await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);\n      __privateWrapper(this, _pendingTransactions)._++;\n      transaction.setGasPayment([{\n        objectId: gasCoin.id,\n        version: gasCoin.version,\n        digest: gasCoin.digest\n      }]);\n      await __privateGet(this, _cache).buildTransaction({\n        transaction,\n        onlyTransactionKind: true\n      });\n    });\n    const bytes = await transaction.build({\n      client: __privateGet(this, _client)\n    });\n    const {\n      signature\n    } = await __privateGet(this, _signer).signTransaction(bytes);\n    const results = await __privateGet(this, _cache).executeTransaction({\n      transaction: bytes,\n      signature: [signature, ...additionalSignatures],\n      options: {\n        ...options,\n        showEffects: true\n      }\n    });\n    const effectsBytes = Uint8Array.from(results.rawEffects);\n    const effects = bcs.TransactionEffects.parse(effectsBytes);\n    const gasResult = getGasCoinFromEffects(effects);\n    const gasUsed = effects.V2?.gasUsed;\n    if (gasCoin && gasUsed && gasResult.owner === __privateGet(this, _signer).toSuiAddress()) {\n      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);\n      const remainingBalance = gasCoin.balance - totalUsed;\n      let usesGasCoin = false;\n      new TransactionDataBuilder(transaction.getData()).mapArguments(arg => {\n        if (arg.$kind === \"GasCoin\") {\n          usesGasCoin = true;\n        }\n        return arg;\n      });\n      if (!usesGasCoin && remainingBalance >= __privateGet(this, _minimumCoinBalance)) {\n        __privateGet(this, _coinPool).push({\n          id: gasResult.ref.objectId,\n          version: gasResult.ref.version,\n          digest: gasResult.ref.digest,\n          balance: remainingBalance\n        });\n      } else {\n        if (!__privateGet(this, _sourceCoins)) {\n          __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n        }\n        __privateGet(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);\n      }\n    }\n    __privateSet(this, _lastDigest, results.digest);\n    return {\n      digest: results.digest,\n      effects: toBase64(effectsBytes),\n      data: results\n    };\n  } catch (error) {\n    if (gasCoin) {\n      if (!__privateGet(this, _sourceCoins)) {\n        __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n      }\n      __privateGet(this, _sourceCoins).set(gasCoin.id, null);\n    }\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {\n      await Promise.all([__privateGet(this, _cache).cache.deleteObjects([...usedObjects]), __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)]);\n    });\n    throw error;\n  } finally {\n    usedObjects.forEach(objectId => {\n      const queue = __privateGet(this, _objectIdQueues).get(objectId);\n      if (queue && queue.length > 0) {\n        queue.shift()();\n      } else if (queue) {\n        __privateGet(this, _objectIdQueues).delete(objectId);\n      }\n    });\n    __privateWrapper(this, _pendingTransactions)._--;\n  }\n};\nupdateCache_fn = async function (fn) {\n  if (__privateGet(this, _cacheLock)) {\n    await __privateGet(this, _cacheLock);\n  }\n  __privateSet(this, _cacheLock, fn?.().then(() => {\n    __privateSet(this, _cacheLock, null);\n  }, () => {}) ?? null);\n};\nwaitForLastDigest_fn = async function () {\n  const digest = __privateGet(this, _lastDigest);\n  if (digest) {\n    __privateSet(this, _lastDigest, null);\n    await __privateGet(this, _client).waitForTransaction({\n      digest\n    });\n  }\n};\ngetGasCoin_fn = async function () {\n  if (__privateGet(this, _coinPool).length === 0 && __privateGet(this, _pendingTransactions) <= __privateGet(this, _maxPoolSize)) {\n    await __privateMethod(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);\n  }\n  if (__privateGet(this, _coinPool).length === 0) {\n    throw new Error(\"No coins available\");\n  }\n  const coin = __privateGet(this, _coinPool).shift();\n  return coin;\n};\ngetGasPrice_fn = async function () {\n  const remaining = __privateGet(this, _gasPrice) ? __privateGet(this, _gasPrice).expiration - __privateGet(this, _epochBoundaryWindow) - Date.now() : 0;\n  if (remaining > 0) {\n    return __privateGet(this, _gasPrice).price;\n  }\n  if (__privateGet(this, _gasPrice)) {\n    const timeToNextEpoch = Math.max(__privateGet(this, _gasPrice).expiration + __privateGet(this, _epochBoundaryWindow) - Date.now(), 1e3);\n    await new Promise(resolve => setTimeout(resolve, timeToNextEpoch));\n  }\n  const state = await __privateGet(this, _client).getLatestSuiSystemState();\n  __privateSet(this, _gasPrice, {\n    price: BigInt(state.referenceGasPrice),\n    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)\n  });\n  return __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);\n};\nrefillCoinPool_fn = async function () {\n  const batchSize = Math.min(__privateGet(this, _coinBatchSize), __privateGet(this, _maxPoolSize) - (__privateGet(this, _coinPool).length + __privateGet(this, _pendingTransactions)) + 1);\n  if (batchSize === 0) {\n    return;\n  }\n  const txb = new Transaction();\n  const address = __privateGet(this, _signer).toSuiAddress();\n  txb.setSender(address);\n  if (__privateGet(this, _sourceCoins)) {\n    const refs = [];\n    const ids = [];\n    for (const [id, ref] of __privateGet(this, _sourceCoins)) {\n      if (ref) {\n        refs.push(ref);\n      } else {\n        ids.push(id);\n      }\n    }\n    if (ids.length > 0) {\n      const coins = await __privateGet(this, _client).multiGetObjects({\n        ids\n      });\n      refs.push(...coins.filter(coin => coin.data !== null).map(({\n        data\n      }) => ({\n        objectId: data.objectId,\n        version: data.version,\n        digest: data.digest\n      })));\n    }\n    txb.setGasPayment(refs);\n    __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n  }\n  const amounts = new Array(batchSize).fill(__privateGet(this, _initialCoinBalance));\n  const results = txb.splitCoins(txb.gas, amounts);\n  const coinResults = [];\n  for (let i = 0; i < amounts.length; i++) {\n    coinResults.push(results[i]);\n  }\n  txb.transferObjects(coinResults, address);\n  await this.waitForLastTransaction();\n  const result = await __privateGet(this, _client).signAndExecuteTransaction({\n    transaction: txb,\n    signer: __privateGet(this, _signer),\n    options: {\n      showRawEffects: true\n    }\n  });\n  const effects = bcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));\n  effects.V2?.changedObjects.forEach(([id, {\n    outputState\n  }], i) => {\n    if (i === effects.V2?.gasObjectIndex || !outputState.ObjectWrite) {\n      return;\n    }\n    __privateGet(this, _coinPool).push({\n      id,\n      version: effects.V2.lamportVersion,\n      digest: outputState.ObjectWrite[0],\n      balance: BigInt(__privateGet(this, _initialCoinBalance))\n    });\n  });\n  if (!__privateGet(this, _sourceCoins)) {\n    __privateSet(this, _sourceCoins, /* @__PURE__ */new Map());\n  }\n  const gasObject = getGasCoinFromEffects(effects).ref;\n  __privateGet(this, _sourceCoins).set(gasObject.objectId, gasObject);\n  await __privateGet(this, _client).waitForTransaction({\n    digest: result.digest\n  });\n};\nexport { ParallelTransactionExecutor };\n//# sourceMappingURL=parallel.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}