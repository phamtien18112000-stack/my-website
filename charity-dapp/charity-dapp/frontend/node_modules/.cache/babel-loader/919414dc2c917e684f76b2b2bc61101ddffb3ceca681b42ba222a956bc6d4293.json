{"ast":null,"code":"import { bigint, object, parse, string } from \"valibot\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { normalizeStructTag } from \"../../utils/sui-types.js\";\nimport { Commands } from \"../Commands.js\";\nimport { Inputs } from \"../Inputs.js\";\nimport { getClient } from \"../json-rpc-resolver.js\";\nconst COIN_WITH_BALANCE = \"CoinWithBalance\";\nconst SUI_TYPE = normalizeStructTag(\"0x2::sui::SUI\");\nfunction coinWithBalance({\n  type = SUI_TYPE,\n  balance,\n  useGasCoin = true\n}) {\n  return tx => {\n    tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n    const coinType = type === \"gas\" ? type : normalizeStructTag(type);\n    return tx.add(Commands.Intent({\n      name: COIN_WITH_BALANCE,\n      inputs: {},\n      data: {\n        type: coinType === SUI_TYPE && useGasCoin ? \"gas\" : coinType,\n        balance: BigInt(balance)\n      }\n    }));\n  };\n}\nconst CoinWithBalanceData = object({\n  type: string(),\n  balance: bigint()\n});\nasync function resolveCoinBalance(transactionData, buildOptions, next) {\n  const coinTypes = /* @__PURE__ */new Set();\n  const totalByType = /* @__PURE__ */new Map();\n  if (!transactionData.sender) {\n    throw new Error(\"Sender must be set to resolve CoinWithBalance\");\n  }\n  for (const command of transactionData.commands) {\n    if (command.$kind === \"$Intent\" && command.$Intent.name === COIN_WITH_BALANCE) {\n      const {\n        type,\n        balance\n      } = parse(CoinWithBalanceData, command.$Intent.data);\n      if (type !== \"gas\" && balance > 0n) {\n        coinTypes.add(type);\n      }\n      totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n    }\n  }\n  const usedIds = /* @__PURE__ */new Set();\n  for (const input of transactionData.inputs) {\n    if (input.Object?.ImmOrOwnedObject) {\n      usedIds.add(input.Object.ImmOrOwnedObject.objectId);\n    }\n    if (input.UnresolvedObject?.objectId) {\n      usedIds.add(input.UnresolvedObject.objectId);\n    }\n  }\n  const coinsByType = /* @__PURE__ */new Map();\n  const client = getClient(buildOptions);\n  await Promise.all([...coinTypes].map(async coinType => {\n    coinsByType.set(coinType, await getCoinsOfType({\n      coinType,\n      balance: totalByType.get(coinType),\n      client,\n      owner: transactionData.sender,\n      usedIds\n    }));\n  }));\n  const mergedCoins = /* @__PURE__ */new Map();\n  mergedCoins.set(\"gas\", {\n    $kind: \"GasCoin\",\n    GasCoin: true\n  });\n  for (const [index, transaction] of transactionData.commands.entries()) {\n    if (transaction.$kind !== \"$Intent\" || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n      continue;\n    }\n    const {\n      type,\n      balance\n    } = transaction.$Intent.data;\n    if (balance === 0n) {\n      transactionData.replaceCommand(index, Commands.MoveCall({\n        target: \"0x2::coin::zero\",\n        typeArguments: [type]\n      }));\n      continue;\n    }\n    const commands = [];\n    if (!mergedCoins.has(type)) {\n      const [first, ...rest] = coinsByType.get(type).map(coin => transactionData.addInput(\"object\", Inputs.ObjectRef({\n        objectId: coin.coinObjectId,\n        digest: coin.digest,\n        version: coin.version\n      })));\n      if (rest.length > 0) {\n        commands.push(Commands.MergeCoins(first, rest));\n      }\n      mergedCoins.set(type, first);\n    }\n    commands.push(Commands.SplitCoins(mergedCoins.get(type), [transactionData.addInput(\"pure\", Inputs.Pure(bcs.u64().serialize(balance)))]));\n    transactionData.replaceCommand(index, commands);\n    transactionData.mapArguments(arg => {\n      if (arg.$kind === \"Result\" && arg.Result === index) {\n        return {\n          $kind: \"NestedResult\",\n          NestedResult: [index + commands.length - 1, 0]\n        };\n      }\n      return arg;\n    });\n  }\n  return next();\n}\nasync function getCoinsOfType({\n  coinType,\n  balance,\n  client,\n  owner,\n  usedIds\n}) {\n  let remainingBalance = balance;\n  const coins = [];\n  return loadMoreCoins();\n  async function loadMoreCoins(cursor = null) {\n    const {\n      data,\n      hasNextPage,\n      nextCursor\n    } = await client.getCoins({\n      owner,\n      coinType,\n      cursor\n    });\n    const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n    for (const coin of sortedCoins) {\n      if (usedIds.has(coin.coinObjectId)) {\n        continue;\n      }\n      const coinBalance = BigInt(coin.balance);\n      coins.push(coin);\n      remainingBalance -= coinBalance;\n      if (remainingBalance <= 0) {\n        return coins;\n      }\n    }\n    if (hasNextPage) {\n      return loadMoreCoins(nextCursor);\n    }\n    throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n  }\n}\nexport { coinWithBalance };\n//# sourceMappingURL=CoinWithBalance.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}