{"ast":null,"code":"\"use client\";\n\n// src/menu.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs, composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { DismissableLayer } from \"@radix-ui/react-dismissable-layer\";\nimport { useFocusGuards } from \"@radix-ui/react-focus-guards\";\nimport { FocusScope } from \"@radix-ui/react-focus-scope\";\nimport { useId } from \"@radix-ui/react-id\";\nimport * as PopperPrimitive from \"@radix-ui/react-popper\";\nimport { createPopperScope } from \"@radix-ui/react-popper\";\nimport { Portal as PortalPrimitive } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport * as RovingFocusGroup from \"@radix-ui/react-roving-focus\";\nimport { createRovingFocusGroupScope } from \"@radix-ui/react-roving-focus\";\nimport { createSlot } from \"@radix-ui/react-slot\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { hideOthers } from \"aria-hidden\";\nimport { RemoveScroll } from \"react-remove-scroll\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SELECTION_KEYS = [\"Enter\", \" \"];\nvar FIRST_KEYS = [\"ArrowDown\", \"PageUp\", \"Home\"];\nvar LAST_KEYS = [\"ArrowUp\", \"PageDown\", \"End\"];\nvar FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nvar SUB_OPEN_KEYS = {\n  ltr: [...SELECTION_KEYS, \"ArrowRight\"],\n  rtl: [...SELECTION_KEYS, \"ArrowLeft\"]\n};\nvar SUB_CLOSE_KEYS = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nvar MENU_NAME = \"Menu\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(MENU_NAME);\nvar [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [createCollectionScope, createPopperScope, createRovingFocusGroupScope]);\nvar usePopperScope = createPopperScope();\nvar useRovingFocusGroupScope = createRovingFocusGroupScope();\nvar [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);\nvar [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);\nvar Menu = props => {\n  const {\n    __scopeMenu,\n    open = false,\n    children,\n    dir,\n    onOpenChange,\n    modal = true\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n  React.useEffect(() => {\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener(\"pointerdown\", handlePointer, {\n        capture: true,\n        once: true\n      });\n      document.addEventListener(\"pointermove\", handlePointer, {\n        capture: true,\n        once: true\n      });\n    };\n    const handlePointer = () => isUsingKeyboardRef.current = false;\n    document.addEventListener(\"keydown\", handleKeyDown, {\n      capture: true\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown, {\n        capture: true\n      });\n      document.removeEventListener(\"pointerdown\", handlePointer, {\n        capture: true\n      });\n      document.removeEventListener(\"pointermove\", handlePointer, {\n        capture: true\n      });\n    };\n  }, []);\n  return /* @__PURE__ */jsx(PopperPrimitive.Root, {\n    ...popperScope,\n    children: /* @__PURE__ */jsx(MenuProvider, {\n      scope: __scopeMenu,\n      open,\n      onOpenChange: handleOpenChange,\n      content,\n      onContentChange: setContent,\n      children: /* @__PURE__ */jsx(MenuRootProvider, {\n        scope: __scopeMenu,\n        onClose: React.useCallback(() => handleOpenChange(false), [handleOpenChange]),\n        isUsingKeyboardRef,\n        dir: direction,\n        modal,\n        children\n      })\n    })\n  });\n};\nMenu.displayName = MENU_NAME;\nvar ANCHOR_NAME = \"MenuAnchor\";\nvar MenuAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...anchorProps\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  return /* @__PURE__ */jsx(PopperPrimitive.Anchor, {\n    ...popperScope,\n    ...anchorProps,\n    ref: forwardedRef\n  });\n});\nMenuAnchor.displayName = ANCHOR_NAME;\nvar PORTAL_NAME = \"MenuPortal\";\nvar [PortalProvider, usePortalContext] = createMenuContext(PORTAL_NAME, {\n  forceMount: void 0\n});\nvar MenuPortal = props => {\n  const {\n    __scopeMenu,\n    forceMount,\n    children,\n    container\n  } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return /* @__PURE__ */jsx(PortalProvider, {\n    scope: __scopeMenu,\n    forceMount,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(PortalPrimitive, {\n        asChild: true,\n        container,\n        children\n      })\n    })\n  });\n};\nMenuPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"MenuContent\";\nvar [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME);\nvar MenuContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n  const {\n    forceMount = portalContext.forceMount,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeMenu,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(Collection.Slot, {\n        scope: props.__scopeMenu,\n        children: rootContext.modal ? /* @__PURE__ */jsx(MenuRootContentModal, {\n          ...contentProps,\n          ref: forwardedRef\n        }) : /* @__PURE__ */jsx(MenuRootContentNonModal, {\n          ...contentProps,\n          ref: forwardedRef\n        })\n      })\n    })\n  });\n});\nvar MenuRootContentModal = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  React.useEffect(() => {\n    const content = ref.current;\n    if (content) return hideOthers(content);\n  }, []);\n  return /* @__PURE__ */jsx(MenuContentImpl, {\n    ...props,\n    ref: composedRefs,\n    trapFocus: context.open,\n    disableOutsidePointerEvents: context.open,\n    disableOutsideScroll: true,\n    onFocusOutside: composeEventHandlers(props.onFocusOutside, event => event.preventDefault(), {\n      checkForDefaultPrevented: false\n    }),\n    onDismiss: () => context.onOpenChange(false)\n  });\n});\nvar MenuRootContentNonModal = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */jsx(MenuContentImpl, {\n    ...props,\n    ref: forwardedRef,\n    trapFocus: false,\n    disableOutsidePointerEvents: false,\n    disableOutsideScroll: false,\n    onDismiss: () => context.onOpenChange(false)\n  });\n});\nvar Slot = createSlot(\"MenuContent.ScrollLock\");\nvar MenuContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    loop = false,\n    trapFocus,\n    onOpenAutoFocus,\n    onCloseAutoFocus,\n    disableOutsidePointerEvents,\n    onEntryFocus,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    disableOutsideScroll,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n  const getItems = useCollection(__scopeMenu);\n  const [currentItemId, setCurrentItemId] = React.useState(null);\n  const contentRef = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n  const timerRef = React.useRef(0);\n  const searchRef = React.useRef(\"\");\n  const pointerGraceTimerRef = React.useRef(0);\n  const pointerGraceIntentRef = React.useRef(null);\n  const pointerDirRef = React.useRef(\"right\");\n  const lastPointerXRef = React.useRef(0);\n  const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n  const scrollLockWrapperProps = disableOutsideScroll ? {\n    as: Slot,\n    allowPinchZoom: true\n  } : void 0;\n  const handleTypeaheadSearch = key => {\n    const search = searchRef.current + key;\n    const items = getItems().filter(item => !item.disabled);\n    const currentItem = document.activeElement;\n    const currentMatch = items.find(item => item.ref.current === currentItem)?.textValue;\n    const values = items.map(item => item.textValue);\n    const nextMatch = getNextMatch(values, search, currentMatch);\n    const newItem = items.find(item => item.textValue === nextMatch)?.ref.current;\n    (function updateSearch(value) {\n      searchRef.current = value;\n      window.clearTimeout(timerRef.current);\n      if (value !== \"\") timerRef.current = window.setTimeout(() => updateSearch(\"\"), 1e3);\n    })(search);\n    if (newItem) {\n      setTimeout(() => newItem.focus());\n    }\n  };\n  React.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n  useFocusGuards();\n  const isPointerMovingToSubmenu = React.useCallback(event => {\n    const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n    return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n  }, []);\n  return /* @__PURE__ */jsx(MenuContentProvider, {\n    scope: __scopeMenu,\n    searchRef,\n    onItemEnter: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) event.preventDefault();\n    }, [isPointerMovingToSubmenu]),\n    onItemLeave: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) return;\n      contentRef.current?.focus();\n      setCurrentItemId(null);\n    }, [isPointerMovingToSubmenu]),\n    onTriggerLeave: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) event.preventDefault();\n    }, [isPointerMovingToSubmenu]),\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange: React.useCallback(intent => {\n      pointerGraceIntentRef.current = intent;\n    }, []),\n    children: /* @__PURE__ */jsx(ScrollLockWrapper, {\n      ...scrollLockWrapperProps,\n      children: /* @__PURE__ */jsx(FocusScope, {\n        asChild: true,\n        trapped: trapFocus,\n        onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, event => {\n          event.preventDefault();\n          contentRef.current?.focus({\n            preventScroll: true\n          });\n        }),\n        onUnmountAutoFocus: onCloseAutoFocus,\n        children: /* @__PURE__ */jsx(DismissableLayer, {\n          asChild: true,\n          disableOutsidePointerEvents,\n          onEscapeKeyDown,\n          onPointerDownOutside,\n          onFocusOutside,\n          onInteractOutside,\n          onDismiss,\n          children: /* @__PURE__ */jsx(RovingFocusGroup.Root, {\n            asChild: true,\n            ...rovingFocusGroupScope,\n            dir: rootContext.dir,\n            orientation: \"vertical\",\n            loop,\n            currentTabStopId: currentItemId,\n            onCurrentTabStopIdChange: setCurrentItemId,\n            onEntryFocus: composeEventHandlers(onEntryFocus, event => {\n              if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n            }),\n            preventScrollOnEntryFocus: true,\n            children: /* @__PURE__ */jsx(PopperPrimitive.Content, {\n              role: \"menu\",\n              \"aria-orientation\": \"vertical\",\n              \"data-state\": getOpenState(context.open),\n              \"data-radix-menu-content\": \"\",\n              dir: rootContext.dir,\n              ...popperScope,\n              ...contentProps,\n              ref: composedRefs,\n              style: {\n                outline: \"none\",\n                ...contentProps.style\n              },\n              onKeyDown: composeEventHandlers(contentProps.onKeyDown, event => {\n                const target = event.target;\n                const isKeyDownInside = target.closest(\"[data-radix-menu-content]\") === event.currentTarget;\n                const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                const isCharacterKey = event.key.length === 1;\n                if (isKeyDownInside) {\n                  if (event.key === \"Tab\") event.preventDefault();\n                  if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                }\n                const content = contentRef.current;\n                if (event.target !== content) return;\n                if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                event.preventDefault();\n                const items = getItems().filter(item => !item.disabled);\n                const candidateNodes = items.map(item => item.ref.current);\n                if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                focusFirst(candidateNodes);\n              }),\n              onBlur: composeEventHandlers(props.onBlur, event => {\n                if (!event.currentTarget.contains(event.target)) {\n                  window.clearTimeout(timerRef.current);\n                  searchRef.current = \"\";\n                }\n              }),\n              onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse(event => {\n                const target = event.target;\n                const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n                if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                  const newDir = event.clientX > lastPointerXRef.current ? \"right\" : \"left\";\n                  pointerDirRef.current = newDir;\n                  lastPointerXRef.current = event.clientX;\n                }\n              }))\n            })\n          })\n        })\n      })\n    })\n  });\n});\nMenuContent.displayName = CONTENT_NAME;\nvar GROUP_NAME = \"MenuGroup\";\nvar MenuGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...groupProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    role: \"group\",\n    ...groupProps,\n    ref: forwardedRef\n  });\n});\nMenuGroup.displayName = GROUP_NAME;\nvar LABEL_NAME = \"MenuLabel\";\nvar MenuLabel = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...labelProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...labelProps,\n    ref: forwardedRef\n  });\n});\nMenuLabel.displayName = LABEL_NAME;\nvar ITEM_NAME = \"MenuItem\";\nvar ITEM_SELECT = \"menu.itemSelect\";\nvar MenuItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    disabled = false,\n    onSelect,\n    ...itemProps\n  } = props;\n  const ref = React.useRef(null);\n  const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n  const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const isPointerDownRef = React.useRef(false);\n  const handleSelect = () => {\n    const menuItem = ref.current;\n    if (!disabled && menuItem) {\n      const itemSelectEvent = new CustomEvent(ITEM_SELECT, {\n        bubbles: true,\n        cancelable: true\n      });\n      menuItem.addEventListener(ITEM_SELECT, event => onSelect?.(event), {\n        once: true\n      });\n      dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n      if (itemSelectEvent.defaultPrevented) {\n        isPointerDownRef.current = false;\n      } else {\n        rootContext.onClose();\n      }\n    }\n  };\n  return /* @__PURE__ */jsx(MenuItemImpl, {\n    ...itemProps,\n    ref: composedRefs,\n    disabled,\n    onClick: composeEventHandlers(props.onClick, handleSelect),\n    onPointerDown: event => {\n      props.onPointerDown?.(event);\n      isPointerDownRef.current = true;\n    },\n    onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n      if (!isPointerDownRef.current) event.currentTarget?.click();\n    }),\n    onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n      const isTypingAhead = contentContext.searchRef.current !== \"\";\n      if (disabled || isTypingAhead && event.key === \" \") return;\n      if (SELECTION_KEYS.includes(event.key)) {\n        event.currentTarget.click();\n        event.preventDefault();\n      }\n    })\n  });\n});\nMenuItem.displayName = ITEM_NAME;\nvar MenuItemImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    disabled = false,\n    textValue,\n    ...itemProps\n  } = props;\n  const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [textContent, setTextContent] = React.useState(\"\");\n  React.useEffect(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      setTextContent((menuItem.textContent ?? \"\").trim());\n    }\n  }, [itemProps.children]);\n  return /* @__PURE__ */jsx(Collection.ItemSlot, {\n    scope: __scopeMenu,\n    disabled,\n    textValue: textValue ?? textContent,\n    children: /* @__PURE__ */jsx(RovingFocusGroup.Item, {\n      asChild: true,\n      ...rovingFocusGroupScope,\n      focusable: !disabled,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        role: \"menuitem\",\n        \"data-highlighted\": isFocused ? \"\" : void 0,\n        \"aria-disabled\": disabled || void 0,\n        \"data-disabled\": disabled ? \"\" : void 0,\n        ...itemProps,\n        ref: composedRefs,\n        onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse(event => {\n          if (disabled) {\n            contentContext.onItemLeave(event);\n          } else {\n            contentContext.onItemEnter(event);\n            if (!event.defaultPrevented) {\n              const item = event.currentTarget;\n              item.focus({\n                preventScroll: true\n              });\n            }\n          }\n        })),\n        onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(event => contentContext.onItemLeave(event))),\n        onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),\n        onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))\n      })\n    })\n  });\n});\nvar CHECKBOX_ITEM_NAME = \"MenuCheckboxItem\";\nvar MenuCheckboxItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    checked = false,\n    onCheckedChange,\n    ...checkboxItemProps\n  } = props;\n  return /* @__PURE__ */jsx(ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked,\n    children: /* @__PURE__ */jsx(MenuItem, {\n      role: \"menuitemcheckbox\",\n      \"aria-checked\": isIndeterminate(checked) ? \"mixed\" : checked,\n      ...checkboxItemProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(checked),\n      onSelect: composeEventHandlers(checkboxItemProps.onSelect, () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked), {\n        checkForDefaultPrevented: false\n      })\n    })\n  });\n});\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\nvar RADIO_GROUP_NAME = \"MenuRadioGroup\";\nvar [RadioGroupProvider, useRadioGroupContext] = createMenuContext(RADIO_GROUP_NAME, {\n  value: void 0,\n  onValueChange: () => {}\n});\nvar MenuRadioGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    value,\n    onValueChange,\n    ...groupProps\n  } = props;\n  const handleValueChange = useCallbackRef(onValueChange);\n  return /* @__PURE__ */jsx(RadioGroupProvider, {\n    scope: props.__scopeMenu,\n    value,\n    onValueChange: handleValueChange,\n    children: /* @__PURE__ */jsx(MenuGroup, {\n      ...groupProps,\n      ref: forwardedRef\n    })\n  });\n});\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\nvar RADIO_ITEM_NAME = \"MenuRadioItem\";\nvar MenuRadioItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    value,\n    ...radioItemProps\n  } = props;\n  const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n  const checked = value === context.value;\n  return /* @__PURE__ */jsx(ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked,\n    children: /* @__PURE__ */jsx(MenuItem, {\n      role: \"menuitemradio\",\n      \"aria-checked\": checked,\n      ...radioItemProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(checked),\n      onSelect: composeEventHandlers(radioItemProps.onSelect, () => context.onValueChange?.(value), {\n        checkForDefaultPrevented: false\n      })\n    })\n  });\n});\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\nvar ITEM_INDICATOR_NAME = \"MenuItemIndicator\";\nvar [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, {\n  checked: false\n});\nvar MenuItemIndicator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    forceMount,\n    ...itemIndicatorProps\n  } = props;\n  const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,\n    children: /* @__PURE__ */jsx(Primitive.span, {\n      ...itemIndicatorProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(indicatorContext.checked)\n    })\n  });\n});\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\nvar SEPARATOR_NAME = \"MenuSeparator\";\nvar MenuSeparator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...separatorProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\",\n    ...separatorProps,\n    ref: forwardedRef\n  });\n});\nMenuSeparator.displayName = SEPARATOR_NAME;\nvar ARROW_NAME = \"MenuArrow\";\nvar MenuArrow = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...arrowProps\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  return /* @__PURE__ */jsx(PopperPrimitive.Arrow, {\n    ...popperScope,\n    ...arrowProps,\n    ref: forwardedRef\n  });\n});\nMenuArrow.displayName = ARROW_NAME;\nvar SUB_NAME = \"MenuSub\";\nvar [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);\nvar MenuSub = props => {\n  const {\n    __scopeMenu,\n    children,\n    open = false,\n    onOpenChange\n  } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState(null);\n  const [content, setContent] = React.useState(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n  return /* @__PURE__ */jsx(PopperPrimitive.Root, {\n    ...popperScope,\n    children: /* @__PURE__ */jsx(MenuProvider, {\n      scope: __scopeMenu,\n      open,\n      onOpenChange: handleOpenChange,\n      content,\n      onContentChange: setContent,\n      children: /* @__PURE__ */jsx(MenuSubProvider, {\n        scope: __scopeMenu,\n        contentId: useId(),\n        triggerId: useId(),\n        trigger,\n        onTriggerChange: setTrigger,\n        children\n      })\n    })\n  });\n};\nMenuSub.displayName = SUB_NAME;\nvar SUB_TRIGGER_NAME = \"MenuSubTrigger\";\nvar MenuSubTrigger = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const openTimerRef = React.useRef(null);\n  const {\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange\n  } = contentContext;\n  const scope = {\n    __scopeMenu: props.__scopeMenu\n  };\n  const clearOpenTimer = React.useCallback(() => {\n    if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = null;\n  }, []);\n  React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n  React.useEffect(() => {\n    const pointerGraceTimer = pointerGraceTimerRef.current;\n    return () => {\n      window.clearTimeout(pointerGraceTimer);\n      onPointerGraceIntentChange(null);\n    };\n  }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n  return /* @__PURE__ */jsx(MenuAnchor, {\n    asChild: true,\n    ...scope,\n    children: /* @__PURE__ */jsx(MenuItemImpl, {\n      id: subContext.triggerId,\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": context.open,\n      \"aria-controls\": subContext.contentId,\n      \"data-state\": getOpenState(context.open),\n      ...props,\n      ref: composeRefs(forwardedRef, subContext.onTriggerChange),\n      onClick: event => {\n        props.onClick?.(event);\n        if (props.disabled || event.defaultPrevented) return;\n        event.currentTarget.focus();\n        if (!context.open) context.onOpenChange(true);\n      },\n      onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse(event => {\n        contentContext.onItemEnter(event);\n        if (event.defaultPrevented) return;\n        if (!props.disabled && !context.open && !openTimerRef.current) {\n          contentContext.onPointerGraceIntentChange(null);\n          openTimerRef.current = window.setTimeout(() => {\n            context.onOpenChange(true);\n            clearOpenTimer();\n          }, 100);\n        }\n      })),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(event => {\n        clearOpenTimer();\n        const contentRect = context.content?.getBoundingClientRect();\n        if (contentRect) {\n          const side = context.content?.dataset.side;\n          const rightSide = side === \"right\";\n          const bleed = rightSide ? -5 : 5;\n          const contentNearEdge = contentRect[rightSide ? \"left\" : \"right\"];\n          const contentFarEdge = contentRect[rightSide ? \"right\" : \"left\"];\n          contentContext.onPointerGraceIntentChange({\n            area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            {\n              x: event.clientX + bleed,\n              y: event.clientY\n            }, {\n              x: contentNearEdge,\n              y: contentRect.top\n            }, {\n              x: contentFarEdge,\n              y: contentRect.top\n            }, {\n              x: contentFarEdge,\n              y: contentRect.bottom\n            }, {\n              x: contentNearEdge,\n              y: contentRect.bottom\n            }],\n            side\n          });\n          window.clearTimeout(pointerGraceTimerRef.current);\n          pointerGraceTimerRef.current = window.setTimeout(() => contentContext.onPointerGraceIntentChange(null), 300);\n        } else {\n          contentContext.onTriggerLeave(event);\n          if (event.defaultPrevented) return;\n          contentContext.onPointerGraceIntentChange(null);\n        }\n      })),\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        const isTypingAhead = contentContext.searchRef.current !== \"\";\n        if (props.disabled || isTypingAhead && event.key === \" \") return;\n        if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n          context.onOpenChange(true);\n          context.content?.focus();\n          event.preventDefault();\n        }\n      })\n    })\n  });\n});\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\nvar SUB_CONTENT_NAME = \"MenuSubContent\";\nvar MenuSubContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n  const {\n    forceMount = portalContext.forceMount,\n    ...subContentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n  const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeMenu,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(Collection.Slot, {\n        scope: props.__scopeMenu,\n        children: /* @__PURE__ */jsx(MenuContentImpl, {\n          id: subContext.contentId,\n          \"aria-labelledby\": subContext.triggerId,\n          ...subContentProps,\n          ref: composedRefs,\n          align: \"start\",\n          side: rootContext.dir === \"rtl\" ? \"left\" : \"right\",\n          disableOutsidePointerEvents: false,\n          disableOutsideScroll: false,\n          trapFocus: false,\n          onOpenAutoFocus: event => {\n            if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n            event.preventDefault();\n          },\n          onCloseAutoFocus: event => event.preventDefault(),\n          onFocusOutside: composeEventHandlers(props.onFocusOutside, event => {\n            if (event.target !== subContext.trigger) context.onOpenChange(false);\n          }),\n          onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, event => {\n            rootContext.onClose();\n            event.preventDefault();\n          }),\n          onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n            const isKeyDownInside = event.currentTarget.contains(event.target);\n            const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n            if (isKeyDownInside && isCloseKey) {\n              context.onOpenChange(false);\n              subContext.trigger?.focus();\n              event.preventDefault();\n            }\n          })\n        })\n      })\n    })\n  });\n});\nMenuSubContent.displayName = SUB_CONTENT_NAME;\nfunction getOpenState(open) {\n  return open ? \"open\" : \"closed\";\n}\nfunction isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\nfunction getCheckedState(checked) {\n  return isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\nfunction focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nfunction getNextMatch(values, search, currentMatch) {\n  const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter(v => v !== currentMatch);\n  const nextMatch = wrappedValues.find(value => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));\n  return nextMatch !== currentMatch ? nextMatch : void 0;\n}\nfunction isPointInPolygon(point, polygon) {\n  const {\n    x,\n    y\n  } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const ii = polygon[i];\n    const jj = polygon[j];\n    const xi = ii.x;\n    const yi = ii.y;\n    const xj = jj.x;\n    const yj = jj.y;\n    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\nfunction isPointerInGraceArea(event, area) {\n  if (!area) return false;\n  const cursorPos = {\n    x: event.clientX,\n    y: event.clientY\n  };\n  return isPointInPolygon(cursorPos, area);\n}\nfunction whenMouse(handler) {\n  return event => event.pointerType === \"mouse\" ? handler(event) : void 0;\n}\nvar Root3 = Menu;\nvar Anchor2 = MenuAnchor;\nvar Portal = MenuPortal;\nvar Content2 = MenuContent;\nvar Group = MenuGroup;\nvar Label = MenuLabel;\nvar Item2 = MenuItem;\nvar CheckboxItem = MenuCheckboxItem;\nvar RadioGroup = MenuRadioGroup;\nvar RadioItem = MenuRadioItem;\nvar ItemIndicator = MenuItemIndicator;\nvar Separator = MenuSeparator;\nvar Arrow2 = MenuArrow;\nvar Sub = MenuSub;\nvar SubTrigger = MenuSubTrigger;\nvar SubContent = MenuSubContent;\nexport { Anchor2 as Anchor, Arrow2 as Arrow, CheckboxItem, Content2 as Content, Group, Item2 as Item, ItemIndicator, Label, Menu, MenuAnchor, MenuArrow, MenuCheckboxItem, MenuContent, MenuGroup, MenuItem, MenuItemIndicator, MenuLabel, MenuPortal, MenuRadioGroup, MenuRadioItem, MenuSeparator, MenuSub, MenuSubContent, MenuSubTrigger, Portal, RadioGroup, RadioItem, Root3 as Root, Separator, Sub, SubContent, SubTrigger, createMenuScope };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}