{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _prefix, _cache;\nconst _ClientCache = class _ClientCache {\n  constructor({\n    prefix,\n    cache\n  } = {}) {\n    __privateAdd(this, _prefix);\n    __privateAdd(this, _cache);\n    __privateSet(this, _prefix, prefix ?? []);\n    __privateSet(this, _cache, cache ?? /* @__PURE__ */new Map());\n  }\n  read(key, load) {\n    const cacheKey = [__privateGet(this, _prefix), ...key].join(\":\");\n    if (__privateGet(this, _cache).has(cacheKey)) {\n      return __privateGet(this, _cache).get(cacheKey);\n    }\n    const result = load();\n    __privateGet(this, _cache).set(cacheKey, result);\n    if (typeof result === \"object\" && result !== null && \"then\" in result) {\n      return Promise.resolve(result).then(v => {\n        __privateGet(this, _cache).set(cacheKey, v);\n        return v;\n      }).catch(err => {\n        __privateGet(this, _cache).delete(cacheKey);\n        throw err;\n      });\n    }\n    return result;\n  }\n  readSync(key, load) {\n    const cacheKey = [__privateGet(this, _prefix), ...key].join(\":\");\n    if (__privateGet(this, _cache).has(cacheKey)) {\n      return __privateGet(this, _cache).get(cacheKey);\n    }\n    const result = load();\n    __privateGet(this, _cache).set(cacheKey, result);\n    return result;\n  }\n  clear(prefix) {\n    const prefixKey = [...__privateGet(this, _prefix), ...(prefix ?? [])].join(\":\");\n    if (!prefixKey) {\n      __privateGet(this, _cache).clear();\n      return;\n    }\n    for (const key of __privateGet(this, _cache).keys()) {\n      if (key.startsWith(prefixKey)) {\n        __privateGet(this, _cache).delete(key);\n      }\n    }\n  }\n  scope(prefix) {\n    return new _ClientCache({\n      prefix: [...__privateGet(this, _prefix), ...(Array.isArray(prefix) ? prefix : [prefix])],\n      cache: __privateGet(this, _cache)\n    });\n  }\n};\n_prefix = new WeakMap();\n_cache = new WeakMap();\nlet ClientCache = _ClientCache;\nexport { ClientCache };\n//# sourceMappingURL=cache.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}