{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _serializationPlugins, _buildPlugins, _intentResolvers, _data, _Transaction_instances, normalizeTransactionArgument_fn, resolveArgument_fn, prepareBuild_fn, runPlugins_fn;\nimport { fromBase64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, parse } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { Commands } from \"./Commands.js\";\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from \"./data/internal.js\";\nimport { serializeV1TransactionData } from \"./data/v1.js\";\nimport { SerializedTransactionDataV2 } from \"./data/v2.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { resolveTransactionData } from \"./json-rpc-resolver.js\";\nimport { createObjectMethods } from \"./object.js\";\nimport { createPure } from \"./pure.js\";\nimport { TransactionDataBuilder } from \"./TransactionData.js\";\nimport { getIdFromCallArg } from \"./utils.js\";\nfunction createTransactionResult(index, length = Infinity) {\n  const baseResult = {\n    $kind: \"Result\",\n    Result: index\n  };\n  const nestedResults = [];\n  const nestedResultFor = resultIndex => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    $kind: \"NestedResult\",\n    NestedResult: [index, resultIndex]\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\"The transaction result is a proxy, and does not support setting properties directly\");\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (i < length) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nfunction isTransaction(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst modulePluginRegistry = {\n  buildPlugins: /* @__PURE__ */new Map(),\n  serializationPlugins: /* @__PURE__ */new Map()\n};\nconst TRANSACTION_REGISTRY_KEY = Symbol.for(\"@mysten/transaction/registry\");\nfunction getGlobalPluginRegistry() {\n  try {\n    const target = globalThis;\n    if (!target[TRANSACTION_REGISTRY_KEY]) {\n      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n    }\n    return target[TRANSACTION_REGISTRY_KEY];\n  } catch (e) {\n    return modulePluginRegistry;\n  }\n}\nconst _Transaction = class _Transaction {\n  constructor() {\n    __privateAdd(this, _Transaction_instances);\n    __privateAdd(this, _serializationPlugins);\n    __privateAdd(this, _buildPlugins);\n    __privateAdd(this, _intentResolvers, /* @__PURE__ */new Map());\n    __privateAdd(this, _data);\n    /**\n     * Add a new object input to the transaction.\n     */\n    this.object = createObjectMethods(value => {\n      if (typeof value === \"function\") {\n        return this.object(value(this));\n      }\n      if (typeof value === \"object\" && is(Argument, value)) {\n        return value;\n      }\n      const id = getIdFromCallArg(value);\n      const inserted = __privateGet(this, _data).inputs.find(i => id === getIdFromCallArg(i));\n      if (inserted?.Object?.SharedObject && typeof value === \"object\" && value.Object?.SharedObject) {\n        inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n      }\n      return inserted ? {\n        $kind: \"Input\",\n        Input: __privateGet(this, _data).inputs.indexOf(inserted),\n        type: \"object\"\n      } : __privateGet(this, _data).addInput(\"object\", typeof value === \"string\" ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: normalizeSuiAddress(value)\n        }\n      } : value);\n    });\n    const globalPlugins = getGlobalPluginRegistry();\n    __privateSet(this, _data, new TransactionDataBuilder());\n    __privateSet(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);\n    __privateSet(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _Transaction();\n    __privateSet(tx, _data, TransactionDataBuilder.fromKindBytes(typeof serialized === \"string\" ? fromBase64(serialized) : serialized));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(transaction) {\n    const newTransaction = new _Transaction();\n    if (isTransaction(transaction)) {\n      __privateSet(newTransaction, _data, new TransactionDataBuilder(transaction.getData()));\n    } else if (typeof transaction !== \"string\" || !transaction.startsWith(\"{\")) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.fromBytes(typeof transaction === \"string\" ? fromBase64(transaction) : transaction));\n    } else {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));\n    }\n    return newTransaction;\n  }\n  static registerGlobalSerializationPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().serializationPlugins.set(stepOrStep, step ?? stepOrStep);\n  }\n  static unregisterGlobalSerializationPlugin(name) {\n    getGlobalPluginRegistry().serializationPlugins.delete(name);\n  }\n  static registerGlobalBuildPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().buildPlugins.set(stepOrStep, step ?? stepOrStep);\n  }\n  static unregisterGlobalBuildPlugin(name) {\n    getGlobalPluginRegistry().buildPlugins.delete(name);\n  }\n  addSerializationPlugin(step) {\n    __privateGet(this, _serializationPlugins).push(step);\n  }\n  addBuildPlugin(step) {\n    __privateGet(this, _buildPlugins).push(step);\n  }\n  addIntentResolver(intent, resolver) {\n    if (__privateGet(this, _intentResolvers).has(intent) && __privateGet(this, _intentResolvers).get(intent) !== resolver) {\n      throw new Error(`Intent resolver for ${intent} already exists`);\n    }\n    __privateGet(this, _intentResolvers).set(intent, resolver);\n  }\n  setSender(sender) {\n    __privateGet(this, _data).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _data).sender) {\n      __privateGet(this, _data).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _data).expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _data).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _data).gasConfig.budget = String(budget);\n  }\n  setGasBudgetIfNotSet(budget) {\n    if (__privateGet(this, _data).gasData.budget == null) {\n      __privateGet(this, _data).gasConfig.budget = String(budget);\n    }\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _data).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _data).gasConfig.payment = payments.map(payment => parse(ObjectRef, payment));\n  }\n  /** @deprecated Use `getData()` instead. */\n  get blockData() {\n    return serializeV1TransactionData(__privateGet(this, _data).snapshot());\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  getData() {\n    return __privateGet(this, _data).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure(value => {\n        if (isSerializedBcs(value)) {\n          return __privateGet(this, _data).addInput(\"pure\", {\n            $kind: \"Pure\",\n            Pure: {\n              bytes: value.toBase64()\n            }\n          });\n        }\n        return __privateGet(this, _data).addInput(\"pure\", is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : {\n          $kind: \"UnresolvedPure\",\n          UnresolvedPure: {\n            value\n          }\n        });\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return {\n      $kind: \"GasCoin\",\n      GasCoin: true\n    };\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  /** Add a transaction to the transaction */\n  add(command) {\n    if (typeof command === \"function\") {\n      return command(this);\n    }\n    const index = __privateGet(this, _data).commands.push(command);\n    return createTransactionResult(index - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    const command = Commands.SplitCoins(typeof coin === \"string\" ? this.object(coin) : __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, coin), amounts.map(amount => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)));\n    const index = __privateGet(this, _data).commands.push(command);\n    return createTransactionResult(index - 1, amounts.length);\n  }\n  mergeCoins(destination, sources) {\n    return this.add(Commands.MergeCoins(this.object(destination), sources.map(src => this.object(src))));\n  }\n  publish({\n    modules,\n    dependencies\n  }) {\n    return this.add(Commands.Publish({\n      modules,\n      dependencies\n    }));\n  }\n  upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return this.add(Commands.Upgrade({\n      modules,\n      dependencies,\n      package: packageId,\n      ticket: this.object(ticket)\n    }));\n  }\n  moveCall({\n    arguments: args,\n    ...input\n  }) {\n    return this.add(Commands.MoveCall({\n      ...input,\n      arguments: args?.map(arg => __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))\n    }));\n  }\n  transferObjects(objects, address) {\n    return this.add(Commands.TransferObjects(objects.map(obj => this.object(obj)), typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)));\n  }\n  makeMoveVec({\n    type,\n    elements\n  }) {\n    return this.add(Commands.MakeMoveVec({\n      type,\n      elements: elements.map(obj => this.object(obj))\n    }));\n  }\n  /**\n   * @deprecated Use toJSON instead.\n   * For synchronous serialization, you can use `getData()`\n   * */\n  serialize() {\n    return JSON.stringify(serializeV1TransactionData(__privateGet(this, _data).snapshot()));\n  }\n  async toJSON(options = {}) {\n    await this.prepareForSerialization(options);\n    return JSON.stringify(parse(SerializedTransactionDataV2, __privateGet(this, _data).snapshot()), (_key, value) => typeof value === \"bigint\" ? value.toString() : value, 2);\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const {\n      signer,\n      ...buildOptions\n    } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransaction(bytes);\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).build({\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).getDigest();\n  }\n  async prepareForSerialization(options) {\n    const intents = /* @__PURE__ */new Set();\n    for (const command of __privateGet(this, _data).commands) {\n      if (command.$Intent) {\n        intents.add(command.$Intent.name);\n      }\n    }\n    const steps = [...__privateGet(this, _serializationPlugins)];\n    for (const intent of intents) {\n      if (options.supportedIntents?.includes(intent)) {\n        continue;\n      }\n      if (!__privateGet(this, _intentResolvers).has(intent)) {\n        throw new Error(`Missing intent resolver for ${intent}`);\n      }\n      steps.push(__privateGet(this, _intentResolvers).get(intent));\n    }\n    await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);\n  }\n};\n_serializationPlugins = new WeakMap();\n_buildPlugins = new WeakMap();\n_intentResolvers = new WeakMap();\n_data = new WeakMap();\n_Transaction_instances = new WeakSet();\nnormalizeTransactionArgument_fn = function (arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, arg);\n};\nresolveArgument_fn = function (arg) {\n  if (typeof arg === \"function\") {\n    return parse(Argument, arg(this));\n  }\n  return parse(Argument, arg);\n};\nprepareBuild_fn = async function (options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _data).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet(this, _buildPlugins), resolveTransactionData], options);\n};\nrunPlugins_fn = async function (plugins, options) {\n  const createNext = i => {\n    if (i >= plugins.length) {\n      return () => {};\n    }\n    const plugin = plugins[i];\n    return async () => {\n      const next = createNext(i + 1);\n      let calledNext = false;\n      let nextResolved = false;\n      await plugin(__privateGet(this, _data), options, async () => {\n        if (calledNext) {\n          throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n        }\n        calledNext = true;\n        await next();\n        nextResolved = true;\n      });\n      if (!calledNext) {\n        throw new Error(`next() was not called in TransactionPlugin ${i}`);\n      }\n      if (!nextResolved) {\n        throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n      }\n    };\n  };\n  await createNext(0)();\n};\nlet Transaction = _Transaction;\nexport { Transaction, isTransaction };\n//# sourceMappingURL=Transaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}