{"ast":null,"code":"// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery({\n  streamFn,\n  refetchMode = \"reset\",\n  reducer = (items, chunk) => addToEnd(items, chunk),\n  initialValue = []\n}) {\n  return async context => {\n    const query = context.client.getQueryCache().find({\n      queryKey: context.queryKey,\n      exact: true\n    });\n    const isRefetch = !!query && query.state.data !== void 0;\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n    let result = initialValue;\n    const stream = await streamFn(context);\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break;\n      }\n      if (!isRefetch || refetchMode !== \"replace\") {\n        context.client.setQueryData(context.queryKey, prev => reducer(prev === void 0 ? initialValue : prev, chunk));\n      }\n      result = reducer(result, chunk);\n    }\n    if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n    return context.client.getQueryData(context.queryKey) ?? initialValue;\n  };\n}\nexport { streamedQuery };\n//# sourceMappingURL=streamedQuery.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}