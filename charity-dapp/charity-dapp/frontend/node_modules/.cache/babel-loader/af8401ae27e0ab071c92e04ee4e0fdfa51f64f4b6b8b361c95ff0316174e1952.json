{"ast":null,"code":"import { getVarName } from '@vanilla-extract/private';\nimport cssesc from 'cssesc';\nimport AhoCorasick from 'modern-ahocorasick';\nimport { markCompositionUsed } from '../adapter/dist/vanilla-extract-css-adapter.browser.esm.js';\nimport { _ as _taggedTemplateLiteral } from './taggedTemplateLiteral-8e47dbd7.browser.esm.js';\nimport { parse } from 'css-what';\nimport dedent from 'dedent';\nimport { toAST } from 'media-query-parser';\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction forEach(obj, fn) {\n  for (var _key in obj) {\n    fn(obj[_key], _key);\n  }\n}\nfunction omit(obj, omitKeys) {\n  var result = {};\n  for (var _key2 in obj) {\n    if (omitKeys.indexOf(_key2) === -1) {\n      result[_key2] = obj[_key2];\n    }\n  }\n  return result;\n}\nfunction mapKeys(obj, fn) {\n  var result = {};\n  for (var _key3 in obj) {\n    result[fn(obj[_key3], _key3)] = obj[_key3];\n  }\n  return result;\n}\nfunction composeStylesIntoSet(set) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    classNames[_key5 - 1] = arguments[_key5];\n  }\n  for (var className of classNames) {\n    if (className.length === 0) {\n      continue;\n    }\n    if (typeof className === 'string') {\n      if (className.includes(' ')) {\n        composeStylesIntoSet(set, ...className.trim().split(' '));\n      } else {\n        set.add(className);\n      }\n    } else if (Array.isArray(className)) {\n      composeStylesIntoSet(set, ...className);\n    }\n  }\n}\nfunction dedupeAndJoinClassList(classNames) {\n  var set = new Set();\n  composeStylesIntoSet(set, ...classNames);\n  return Array.from(set).join(' ');\n}\nvar _templateObject$1;\n\n// https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction escapeRegex(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nvar validateSelector = (selector, targetClassName) => {\n  var replaceTarget = () => {\n    var targetRegex = new RegExp(\".\".concat(escapeRegex(cssesc(targetClassName, {\n      isIdentifier: true\n    }))), 'g');\n    return selector.replace(targetRegex, '&');\n  };\n  var selectorParts;\n  try {\n    selectorParts = parse(selector);\n  } catch (err) {\n    throw new Error(\"Invalid selector: \".concat(replaceTarget()), {\n      cause: err\n    });\n  }\n  selectorParts.forEach(tokens => {\n    try {\n      for (var i = tokens.length - 1; i >= -1; i--) {\n        if (!tokens[i]) {\n          throw new Error();\n        }\n        var token = tokens[i];\n        if (token.type === 'child' || token.type === 'parent' || token.type === 'sibling' || token.type === 'adjacent' || token.type === 'descendant') {\n          throw new Error();\n        }\n        if (token.type === 'attribute' && token.name === 'class' && token.value === targetClassName) {\n          return; // Found it\n        }\n      }\n    } catch (err) {\n      throw new Error(dedent(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([\"\\n        Invalid selector: \", \"\\n    \\n        Style selectors must target the '&' character (along with any modifiers), e.g. \", \" or \", \".\\n        \\n        This is to ensure that each style block only affects the styling of a single class.\\n        \\n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of \", \") to 'parent', you should add \", \" to 'child').\\n        \\n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write \", \", you should instead write 'globalStyle(\", \", { ... })'\\n      \"])), replaceTarget(), '`${parent} &`', '`${parent} &:hover`', '`& ${child}`', '`${parent} &`', '`& h1`', '`${parent} h1`'), {\n        cause: err\n      });\n    }\n  });\n};\n\n/** e.g. @media screen and (min-width: 500px) */\n\nclass ConditionalRuleset {\n  /**\n   * Stores information about where conditions must be in relation to other conditions\n   *\n   * e.g. mobile -> tablet, desktop\n   */\n\n  constructor() {\n    this.ruleset = new Map();\n    this.precedenceLookup = new Map();\n  }\n  findOrCreateCondition(conditionQuery) {\n    var targetCondition = this.ruleset.get(conditionQuery);\n    if (!targetCondition) {\n      // No target condition so create one\n      targetCondition = {\n        query: conditionQuery,\n        rules: [],\n        children: new ConditionalRuleset()\n      };\n      this.ruleset.set(conditionQuery, targetCondition);\n    }\n    return targetCondition;\n  }\n  getConditionalRulesetByPath(conditionPath) {\n    var currRuleset = this;\n    for (var query of conditionPath) {\n      var condition = currRuleset.findOrCreateCondition(query);\n      currRuleset = condition.children;\n    }\n    return currRuleset;\n  }\n  addRule(rule, conditionQuery, conditionPath) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    var targetCondition = ruleset.findOrCreateCondition(conditionQuery);\n    if (!targetCondition) {\n      throw new Error('Failed to add conditional rule');\n    }\n    targetCondition.rules.push(rule);\n  }\n  addConditionPrecedence(conditionPath, conditionOrder) {\n    var ruleset = this.getConditionalRulesetByPath(conditionPath);\n    for (var i = 0; i < conditionOrder.length; i++) {\n      var _ruleset$precedenceLo;\n      var query = conditionOrder[i];\n      var conditionPrecedence = (_ruleset$precedenceLo = ruleset.precedenceLookup.get(query)) !== null && _ruleset$precedenceLo !== void 0 ? _ruleset$precedenceLo : new Set();\n      for (var lowerPrecedenceCondition of conditionOrder.slice(i + 1)) {\n        conditionPrecedence.add(lowerPrecedenceCondition);\n      }\n      ruleset.precedenceLookup.set(query, conditionPrecedence);\n    }\n  }\n  isCompatible(incomingRuleset) {\n    for (var [condition, orderPrecedence] of this.precedenceLookup.entries()) {\n      for (var lowerPrecedenceCondition of orderPrecedence) {\n        var _incomingRuleset$prec;\n        if ((_incomingRuleset$prec = incomingRuleset.precedenceLookup.get(lowerPrecedenceCondition)) !== null && _incomingRuleset$prec !== void 0 && _incomingRuleset$prec.has(condition)) {\n          return false;\n        }\n      }\n    }\n\n    // Check that children are compatible\n    for (var {\n      query,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition && !matchingCondition.children.isCompatible(children)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  merge(incomingRuleset) {\n    // Merge rulesets into one array\n    for (var {\n      query,\n      rules,\n      children\n    } of incomingRuleset.ruleset.values()) {\n      var matchingCondition = this.ruleset.get(query);\n      if (matchingCondition) {\n        matchingCondition.rules.push(...rules);\n        matchingCondition.children.merge(children);\n      } else {\n        this.ruleset.set(query, {\n          query,\n          rules,\n          children\n        });\n      }\n    }\n\n    // Merge order precedences\n    for (var [condition, incomingOrderPrecedence] of incomingRuleset.precedenceLookup.entries()) {\n      var _this$precedenceLooku;\n      var orderPrecedence = (_this$precedenceLooku = this.precedenceLookup.get(condition)) !== null && _this$precedenceLooku !== void 0 ? _this$precedenceLooku : new Set();\n      this.precedenceLookup.set(condition, new Set([...orderPrecedence, ...incomingOrderPrecedence]));\n    }\n  }\n\n  /**\n   * Merge another ConditionalRuleset into this one if they are compatible\n   *\n   * @returns true if successful, false if the ruleset is incompatible\n   */\n  mergeIfCompatible(incomingRuleset) {\n    if (!this.isCompatible(incomingRuleset)) {\n      return false;\n    }\n    this.merge(incomingRuleset);\n    return true;\n  }\n  getSortedRuleset() {\n    var _this = this;\n    var sortedRuleset = [];\n\n    // Loop through all queries and add them to the sorted ruleset\n    var _loop = function _loop(dependents) {\n      var conditionForQuery = _this.ruleset.get(query);\n      if (!conditionForQuery) {\n        throw new Error(\"Can't find condition for \".concat(query));\n      }\n\n      // Find the location of the first dependent condition in the sortedRuleset\n      // A dependent condition is a condition that must be placed *after* the current one\n      var firstMatchingDependent = sortedRuleset.findIndex(condition => dependents.has(condition.query));\n      if (firstMatchingDependent > -1) {\n        // Insert the condition before the dependent one\n        sortedRuleset.splice(firstMatchingDependent, 0, conditionForQuery);\n      } else {\n        // No match, just insert at the end\n        sortedRuleset.push(conditionForQuery);\n      }\n    };\n    for (var [query, dependents] of this.precedenceLookup.entries()) {\n      _loop(dependents);\n    }\n    return sortedRuleset;\n  }\n  renderToArray() {\n    var arr = [];\n    for (var {\n      query,\n      rules,\n      children\n    } of this.getSortedRuleset()) {\n      var selectors = {};\n      for (var rule of rules) {\n        selectors[rule.selector] = _objectSpread2(_objectSpread2({}, selectors[rule.selector]), rule.rule);\n      }\n      Object.assign(selectors, ...children.renderToArray());\n      arr.push({\n        [query]: selectors\n      });\n    }\n    return arr;\n  }\n}\nvar simplePseudoMap = {\n  ':-moz-any-link': true,\n  ':-moz-full-screen': true,\n  ':-moz-placeholder': true,\n  ':-moz-read-only': true,\n  ':-moz-read-write': true,\n  ':-ms-fullscreen': true,\n  ':-ms-input-placeholder': true,\n  ':-webkit-any-link': true,\n  ':-webkit-full-screen': true,\n  '::-moz-color-swatch': true,\n  '::-moz-list-bullet': true,\n  '::-moz-list-number': true,\n  '::-moz-page-sequence': true,\n  '::-moz-page': true,\n  '::-moz-placeholder': true,\n  '::-moz-progress-bar': true,\n  '::-moz-range-progress': true,\n  '::-moz-range-thumb': true,\n  '::-moz-range-track': true,\n  '::-moz-scrolled-page-sequence': true,\n  '::-moz-selection': true,\n  '::-ms-backdrop': true,\n  '::-ms-browse': true,\n  '::-ms-check': true,\n  '::-ms-clear': true,\n  '::-ms-fill-lower': true,\n  '::-ms-fill-upper': true,\n  '::-ms-fill': true,\n  '::-ms-reveal': true,\n  '::-ms-thumb': true,\n  '::-ms-ticks-after': true,\n  '::-ms-ticks-before': true,\n  '::-ms-tooltip': true,\n  '::-ms-track': true,\n  '::-ms-value': true,\n  '::-webkit-backdrop': true,\n  '::-webkit-calendar-picker-indicator': true,\n  '::-webkit-inner-spin-button': true,\n  '::-webkit-input-placeholder': true,\n  '::-webkit-meter-bar': true,\n  '::-webkit-meter-even-less-good-value': true,\n  '::-webkit-meter-inner-element': true,\n  '::-webkit-meter-optimum-value': true,\n  '::-webkit-meter-suboptimum-value': true,\n  '::-webkit-outer-spin-button': true,\n  '::-webkit-progress-bar': true,\n  '::-webkit-progress-inner-element': true,\n  '::-webkit-progress-inner-value': true,\n  '::-webkit-progress-value': true,\n  '::-webkit-resizer': true,\n  '::-webkit-scrollbar-button': true,\n  '::-webkit-scrollbar-corner': true,\n  '::-webkit-scrollbar-thumb': true,\n  '::-webkit-scrollbar-track-piece': true,\n  '::-webkit-scrollbar-track': true,\n  '::-webkit-scrollbar': true,\n  '::-webkit-search-cancel-button': true,\n  '::-webkit-search-results-button': true,\n  '::-webkit-slider-runnable-track': true,\n  '::-webkit-slider-thumb': true,\n  '::after': true,\n  '::backdrop': true,\n  '::before': true,\n  '::cue': true,\n  '::file-selector-button': true,\n  '::first-letter': true,\n  '::first-line': true,\n  '::grammar-error': true,\n  '::marker': true,\n  '::placeholder': true,\n  '::selection': true,\n  '::spelling-error': true,\n  '::target-text': true,\n  '::view-transition-group': true,\n  '::view-transition-image-pair': true,\n  '::view-transition-new': true,\n  '::view-transition-old': true,\n  '::view-transition': true,\n  ':active': true,\n  ':after': true,\n  ':any-link': true,\n  ':before': true,\n  ':blank': true,\n  ':checked': true,\n  ':default': true,\n  ':defined': true,\n  ':disabled': true,\n  ':empty': true,\n  ':enabled': true,\n  ':first-child': true,\n  ':first-letter': true,\n  ':first-line': true,\n  ':first-of-type': true,\n  ':first': true,\n  ':focus-visible': true,\n  ':focus-within': true,\n  ':focus': true,\n  ':fullscreen': true,\n  ':hover': true,\n  ':in-range': true,\n  ':indeterminate': true,\n  ':invalid': true,\n  ':last-child': true,\n  ':last-of-type': true,\n  ':left': true,\n  ':link': true,\n  ':only-child': true,\n  ':only-of-type': true,\n  ':optional': true,\n  ':out-of-range': true,\n  ':placeholder-shown': true,\n  ':read-only': true,\n  ':read-write': true,\n  ':required': true,\n  ':right': true,\n  ':root': true,\n  ':scope': true,\n  ':target': true,\n  ':valid': true,\n  ':visited': true\n};\nvar simplePseudos = Object.keys(simplePseudoMap);\nvar simplePseudoLookup = simplePseudoMap;\nvar _templateObject;\nvar createMediaQueryError = (mediaQuery, msg) => new Error(dedent(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    Invalid media query: \\\"\", \"\\\"\\n\\n    \", \"\\n\\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\\n  \"])), mediaQuery, msg));\nvar validateMediaQuery = mediaQuery => {\n  // Empty queries will start with '@media '\n  if (mediaQuery === '@media ') {\n    throw createMediaQueryError(mediaQuery, 'Query is empty');\n  }\n  try {\n    toAST(mediaQuery);\n  } catch (e) {\n    throw createMediaQueryError(mediaQuery, e.message);\n  }\n};\nvar _excluded = [\"vars\"],\n  _excluded2 = [\"content\"];\nvar DECLARATION = '__DECLARATION';\nvar UNITLESS = {\n  animationIterationCount: true,\n  borderImage: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  gridArea: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnStart: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowStart: true,\n  initialLetter: true,\n  lineClamp: true,\n  lineHeight: true,\n  maxLines: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  scale: true,\n  tabSize: true,\n  WebkitLineClamp: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // svg properties\n  fillOpacity: true,\n  floodOpacity: true,\n  maskBorder: true,\n  maskBorderOutset: true,\n  maskBorderSlice: true,\n  maskBorderWidth: true,\n  shapeImageThreshold: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\nfunction dashify(str) {\n  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();\n}\nfunction replaceBetweenIndexes(target, startIndex, endIndex, replacement) {\n  var start = target.slice(0, startIndex);\n  var end = target.slice(endIndex);\n  return \"\".concat(start).concat(replacement).concat(end);\n}\nvar DOUBLE_SPACE = '  ';\nvar specialKeys = [...simplePseudos, '@layer', '@media', '@supports', '@container', '@starting-style', 'selectors'];\nclass Stylesheet {\n  constructor(localClassNames, composedClassLists) {\n    this.rules = [];\n    this.conditionalRulesets = [new ConditionalRuleset()];\n    this.fontFaceRules = [];\n    this.keyframesRules = [];\n    this.propertyRules = [];\n    this.localClassNamesMap = new Map(localClassNames.map(localClassName => [localClassName, localClassName]));\n    this.localClassNamesSearch = new AhoCorasick(localClassNames);\n    this.layers = new Map();\n\n    // Class list compositions should be priortized by Newer > Older\n    // Therefore we reverse the array as they are added in sequence\n    this.composedClassLists = composedClassLists.map(_ref => {\n      var {\n        identifier,\n        classList\n      } = _ref;\n      return {\n        identifier,\n        regex: RegExp(\"(\".concat(classList, \")\"), 'g')\n      };\n    }).reverse();\n  }\n  processCssObj(root) {\n    if (root.type === 'fontFace') {\n      this.fontFaceRules.push(root.rule);\n      return;\n    }\n    if (root.type === 'property') {\n      this.propertyRules.push(root);\n      return;\n    }\n    if (root.type === 'keyframes') {\n      root.rule = Object.fromEntries(Object.entries(root.rule).map(_ref2 => {\n        var [keyframe, rule] = _ref2;\n        return [keyframe, this.transformVars(this.transformProperties(rule))];\n      }));\n      this.keyframesRules.push(root);\n      return;\n    }\n    this.currConditionalRuleset = new ConditionalRuleset();\n    if (root.type === 'layer') {\n      var layerDefinition = \"@layer \".concat(root.name);\n      this.addLayer([layerDefinition]);\n    } else {\n      // Add main styles\n      var mainRule = omit(root.rule, specialKeys);\n      this.addRule({\n        selector: root.selector,\n        rule: mainRule\n      });\n      this.transformLayer(root, root.rule['@layer']);\n      this.transformMedia(root, root.rule['@media']);\n      this.transformSupports(root, root.rule['@supports']);\n      this.transformContainer(root, root.rule['@container']);\n      this.transformStartingStyle(root, root.rule['@starting-style']);\n      this.transformSimplePseudos(root, root.rule);\n      this.transformSelectors(root, root.rule);\n    }\n    var activeConditionalRuleset = this.conditionalRulesets[this.conditionalRulesets.length - 1];\n    if (!activeConditionalRuleset.mergeIfCompatible(this.currConditionalRuleset)) {\n      // Ruleset merge failed due to incompatibility. We now deopt by starting a fresh ConditionalRuleset\n      this.conditionalRulesets.push(this.currConditionalRuleset);\n    }\n  }\n  addConditionalRule(cssRule, conditions) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    if (!this.currConditionalRuleset) {\n      throw new Error(\"Couldn't add conditional rule\");\n    }\n    var conditionQuery = conditions[conditions.length - 1];\n    var parentConditions = conditions.slice(0, conditions.length - 1);\n    this.currConditionalRuleset.addRule({\n      selector,\n      rule\n    }, conditionQuery, parentConditions);\n  }\n  addRule(cssRule) {\n    // Run `transformProperties` before `transformVars` as we don't want to pixelify CSS Vars\n    var rule = this.transformVars(this.transformProperties(cssRule.rule));\n    var selector = this.transformSelector(cssRule.selector);\n    this.rules.push({\n      selector,\n      rule\n    });\n  }\n  addLayer(layer) {\n    var uniqueLayerKey = layer.join(' - ');\n    this.layers.set(uniqueLayerKey, layer);\n  }\n  transformProperties(cssRule) {\n    return this.transformContent(this.pixelifyProperties(cssRule));\n  }\n  pixelifyProperties(cssRule) {\n    forEach(cssRule, (value, key) => {\n      if (typeof value === 'number' && value !== 0 && !UNITLESS[key]) {\n        // @ts-expect-error Any ideas?\n        cssRule[key] = \"\".concat(value, \"px\");\n      }\n    });\n    return cssRule;\n  }\n  transformVars(_ref3) {\n    var {\n        vars\n      } = _ref3,\n      rest = _objectWithoutProperties(_ref3, _excluded);\n    if (!vars) {\n      return rest;\n    }\n    return _objectSpread2(_objectSpread2({}, mapKeys(vars, (_value, key) => getVarName(key))), rest);\n  }\n  transformContent(_ref4) {\n    var {\n        content\n      } = _ref4,\n      rest = _objectWithoutProperties(_ref4, _excluded2);\n    if (typeof content === 'undefined') {\n      return rest;\n    }\n\n    // Handle fallback arrays:\n    var contentArray = Array.isArray(content) ? content : [content];\n    return _objectSpread2({\n      content: contentArray.map(value =>\n      // This logic was adapted from Stitches :)\n      value && (value.includes('\"') || value.includes(\"'\") || /^([A-Za-z-]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\\s|$)/.test(value)) ? value : \"\\\"\".concat(value, \"\\\"\"))\n    }, rest);\n  }\n  transformClassname(identifier) {\n    return \".\".concat(cssesc(identifier, {\n      isIdentifier: true\n    }));\n  }\n  transformSelector(selector) {\n    // Map class list compositions to single identifiers\n    var transformedSelector = selector;\n    var _loop = function _loop(identifier) {\n      transformedSelector = transformedSelector.replace(regex, () => {\n        markCompositionUsed(identifier);\n        return identifier;\n      });\n    };\n    for (var {\n      identifier,\n      regex\n    } of this.composedClassLists) {\n      _loop(identifier);\n    }\n    if (this.localClassNamesMap.has(transformedSelector)) {\n      return this.transformClassname(transformedSelector);\n    }\n    var results = this.localClassNamesSearch.search(transformedSelector);\n    var lastReplaceIndex = transformedSelector.length;\n\n    // Perform replacements backwards to simplify index handling\n    for (var i = results.length - 1; i >= 0; i--) {\n      var [endIndex, [firstMatch]] = results[i];\n      var startIndex = endIndex - firstMatch.length + 1;\n\n      // Class names can be substrings of other class names\n      // e.g. '_1g1ptzo1' and '_1g1ptzo10'\n      //\n      // Additionally, concatenated classnames can contain substrings equal to other classnames\n      // e.g. '&&' where '&' is 'debugName_hash1' and 'debugName_hash1d' is also a local classname\n      // Before transforming the selector, this would look like `debugName_hash1debugName_hash1`\n      // which contains the substring `debugName_hash1d`â€™.\n      //\n      // In either of these cases, the last replace index will occur either before or within the\n      // current replacement range (from `startIndex` to `endIndex`).\n      // If this occurs, we skip the replacement to avoid transforming the selector incorrectly.\n      var skipReplacement = lastReplaceIndex <= endIndex;\n      if (skipReplacement) {\n        continue;\n      }\n      lastReplaceIndex = startIndex;\n\n      // If class names already starts with a '.' then skip\n      if (transformedSelector[startIndex - 1] !== '.') {\n        transformedSelector = replaceBetweenIndexes(transformedSelector, startIndex, endIndex + 1, this.transformClassname(firstMatch));\n      }\n    }\n    return transformedSelector;\n  }\n  transformSelectors(root, rule, conditions) {\n    forEach(rule.selectors, (selectorRule, selector) => {\n      if (root.type !== 'local') {\n        throw new Error(\"Selectors are not allowed within \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n      }\n      var transformedSelector = this.transformSelector(selector.replace(RegExp('&', 'g'), root.selector));\n      validateSelector(transformedSelector, root.selector);\n      var rule = {\n        selector: transformedSelector,\n        rule: omit(selectorRule, specialKeys)\n      };\n      if (conditions) {\n        this.addConditionalRule(rule, conditions);\n      } else {\n        this.addRule(rule);\n      }\n      var selectorRoot = {\n        type: 'selector',\n        selector: transformedSelector,\n        rule: selectorRule\n      };\n      this.transformLayer(selectorRoot, selectorRule['@layer'], conditions);\n      this.transformSupports(selectorRoot, selectorRule['@supports'], conditions);\n      this.transformMedia(selectorRoot, selectorRule['@media'], conditions);\n      this.transformContainer(selectorRoot, selectorRule['@container'], conditions);\n      this.transformStartingStyle(selectorRoot, selectorRule['@starting-style'], conditions);\n    });\n  }\n  transformMedia(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional;\n      (_this$currConditional = this.currConditionalRuleset) === null || _this$currConditional === void 0 || _this$currConditional.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@media \".concat(query)));\n      for (var [query, mediaRule] of Object.entries(rules)) {\n        var mediaQuery = \"@media \".concat(query);\n        validateMediaQuery(mediaQuery);\n        var conditions = [...parentConditions, mediaQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(mediaRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, mediaRule, conditions);\n          this.transformSelectors(root, mediaRule, conditions);\n        }\n        this.transformLayer(root, mediaRule['@layer'], conditions);\n        this.transformSupports(root, mediaRule['@supports'], conditions);\n        this.transformContainer(root, mediaRule['@container'], conditions);\n        this.transformStartingStyle(root, mediaRule['@starting-style'], conditions);\n      }\n    }\n  }\n  transformContainer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional2;\n      (_this$currConditional2 = this.currConditionalRuleset) === null || _this$currConditional2 === void 0 || _this$currConditional2.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@container \".concat(query)));\n      forEach(rules, (containerRule, query) => {\n        var containerQuery = \"@container \".concat(query);\n        var conditions = [...parentConditions, containerQuery];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(containerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, containerRule, conditions);\n          this.transformSelectors(root, containerRule, conditions);\n        }\n        this.transformLayer(root, containerRule['@layer'], conditions);\n        this.transformSupports(root, containerRule['@supports'], conditions);\n        this.transformMedia(root, containerRule['@media'], conditions);\n        this.transformStartingStyle(root, containerRule['@starting-style'], conditions);\n      });\n    }\n  }\n  transformLayer(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional3;\n      (_this$currConditional3 = this.currConditionalRuleset) === null || _this$currConditional3 === void 0 || _this$currConditional3.addConditionPrecedence(parentConditions, Object.keys(rules).map(name => \"@layer \".concat(name)));\n      forEach(rules, (layerRule, name) => {\n        var conditions = [...parentConditions, \"@layer \".concat(name)];\n        this.addLayer(conditions);\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(layerRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, layerRule, conditions);\n          this.transformSelectors(root, layerRule, conditions);\n        }\n        this.transformMedia(root, layerRule['@media'], conditions);\n        this.transformSupports(root, layerRule['@supports'], conditions);\n        this.transformContainer(root, layerRule['@container'], conditions);\n        this.transformStartingStyle(root, layerRule['@starting-style'], conditions);\n      });\n    }\n  }\n  transformSupports(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional4;\n      (_this$currConditional4 = this.currConditionalRuleset) === null || _this$currConditional4 === void 0 || _this$currConditional4.addConditionPrecedence(parentConditions, Object.keys(rules).map(query => \"@supports \".concat(query)));\n      forEach(rules, (supportsRule, query) => {\n        var conditions = [...parentConditions, \"@supports \".concat(query)];\n        this.addConditionalRule({\n          selector: root.selector,\n          rule: omit(supportsRule, specialKeys)\n        }, conditions);\n        if (root.type === 'local') {\n          this.transformSimplePseudos(root, supportsRule, conditions);\n          this.transformSelectors(root, supportsRule, conditions);\n        }\n        this.transformLayer(root, supportsRule['@layer'], conditions);\n        this.transformMedia(root, supportsRule['@media'], conditions);\n        this.transformContainer(root, supportsRule['@container'], conditions);\n        this.transformStartingStyle(root, supportsRule['@starting-style'], conditions);\n      });\n    }\n  }\n  transformSimplePseudos(root, rule, conditions) {\n    for (var key of Object.keys(rule)) {\n      // Process simple pseudos\n      if (simplePseudoLookup[key]) {\n        if (root.type !== 'local') {\n          throw new Error(\"Simple pseudos are not valid in \".concat(root.type === 'global' ? '\"globalStyle\"' : '\"selectors\"'));\n        }\n        if (conditions) {\n          this.addConditionalRule({\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          }, conditions);\n        } else {\n          this.addRule({\n            conditions,\n            selector: \"\".concat(root.selector).concat(key),\n            rule: rule[key]\n          });\n        }\n      }\n    }\n  }\n  transformStartingStyle(root, rules) {\n    var parentConditions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (rules) {\n      var _this$currConditional5;\n      var nestedAtRuleKey = Object.keys(rules).find(key => key.startsWith('@'));\n      if (nestedAtRuleKey) {\n        throw new Error(\"Nested at-rules (e.g. \\\"\".concat(nestedAtRuleKey, \"\\\") are not allowed inside @starting-style.\"));\n      }\n      (_this$currConditional5 = this.currConditionalRuleset) === null || _this$currConditional5 === void 0 || _this$currConditional5.addConditionPrecedence(parentConditions, ['@starting-style']);\n      var conditions = [...parentConditions, '@starting-style'];\n      this.addConditionalRule({\n        selector: root.selector,\n        rule: omit(rules, specialKeys)\n      }, conditions);\n      if (root.type === 'local') {\n        this.transformSimplePseudos(root, rules, conditions);\n        this.transformSelectors(root, rules, conditions);\n      }\n    }\n  }\n  toCss() {\n    var css = [];\n\n    // Render font-face rules\n    for (var fontFaceRule of this.fontFaceRules) {\n      css.push(renderCss({\n        '@font-face': fontFaceRule\n      }));\n    }\n\n    // Render property rules\n    for (var property of this.propertyRules) {\n      css.push(renderCss({\n        [\"@property \".concat(property.name)]: property.rule\n      }));\n    }\n\n    // Render keyframes\n    for (var keyframe of this.keyframesRules) {\n      css.push(renderCss({\n        [\"@keyframes \".concat(keyframe.name)]: keyframe.rule\n      }));\n    }\n\n    // Render layer definitions\n    for (var layer of this.layers.values()) {\n      var [definition, ...nesting] = layer.reverse();\n      var cssObj = {\n        [definition]: DECLARATION\n      };\n      for (var part of nesting) {\n        cssObj = {\n          [part]: cssObj\n        };\n      }\n      css.push(renderCss(cssObj));\n    }\n\n    // Render unconditional rules\n    for (var rule of this.rules) {\n      css.push(renderCss({\n        [rule.selector]: rule.rule\n      }));\n    }\n\n    // Render conditional rules\n    for (var conditionalRuleset of this.conditionalRulesets) {\n      for (var conditionalRule of conditionalRuleset.renderToArray()) {\n        css.push(renderCss(conditionalRule));\n      }\n    }\n    return css.filter(Boolean);\n  }\n}\nfunction renderCss(v) {\n  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var rules = [];\n  var _loop2 = function _loop2(key) {\n    var value = v[key];\n    if (value && Array.isArray(value)) {\n      rules.push(...value.map(v => renderCss({\n        [key]: v\n      }, indent)));\n    } else if (value && typeof value === 'object') {\n      var isEmpty = Object.keys(value).length === 0;\n      if (!isEmpty) {\n        rules.push(\"\".concat(indent).concat(key, \" {\\n\").concat(renderCss(value, indent + DOUBLE_SPACE), \"\\n\").concat(indent, \"}\"));\n      }\n    } else if (value === DECLARATION) {\n      rules.push(\"\".concat(indent).concat(key, \";\"));\n    } else {\n      rules.push(\"\".concat(indent).concat(key.startsWith('--') ? key : dashify(key), \": \").concat(value, \";\"));\n    }\n  };\n  for (var key of Object.keys(v)) {\n    _loop2(key);\n  }\n  return rules.join('\\n');\n}\nfunction transformCss(_ref5) {\n  var {\n    localClassNames,\n    cssObjs,\n    composedClassLists\n  } = _ref5;\n  var stylesheet = new Stylesheet(localClassNames, composedClassLists);\n  for (var root of cssObjs) {\n    stylesheet.processCssObj(root);\n  }\n  return stylesheet.toCss();\n}\nexport { _objectSpread2 as _, _objectWithoutProperties as a, dedupeAndJoinClassList as d, transformCss as t };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}