{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _events, _accounts, _origin, _name, _network, _signTransactionBlock, _signTransaction, _signPersonalMessage, _on, _StashedWallet_instances, setAccount_fn, _connect, _disconnect;\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { toBase64 } from \"@mysten/sui/utils\";\nimport { getWallets, ReadonlyWalletAccount, SUI_MAINNET_CHAIN } from \"@mysten/wallet-standard\";\nimport mitt from \"mitt\";\nimport { DEFAULT_STASHED_ORIGIN, StashedPopup } from \"./channel/index.js\";\nconst STASHED_RECENT_ADDRESS_KEY = \"stashed:recentAddress\";\nconst STASHED_WALLET_NAME = \"Stashed\";\nclass StashedWallet {\n  constructor({\n    name,\n    network,\n    address,\n    origin = DEFAULT_STASHED_ORIGIN\n  }) {\n    __privateAdd(this, _StashedWallet_instances);\n    __privateAdd(this, _events);\n    __privateAdd(this, _accounts);\n    __privateAdd(this, _origin);\n    __privateAdd(this, _name);\n    __privateAdd(this, _network);\n    __privateAdd(this, _signTransactionBlock, async ({\n      transactionBlock,\n      account\n    }) => {\n      transactionBlock.setSenderIfNotSet(account.address);\n      const data = transactionBlock.serialize();\n      const popup = new StashedPopup({\n        name: __privateGet(this, _name),\n        origin: __privateGet(this, _origin),\n        network: __privateGet(this, _network)\n      });\n      const response = await popup.send({\n        type: \"sign-transaction-block\",\n        data,\n        address: account.address\n      });\n      return {\n        transactionBlockBytes: response.bytes,\n        signature: response.signature\n      };\n    });\n    __privateAdd(this, _signTransaction, async ({\n      transaction,\n      account\n    }) => {\n      const popup = new StashedPopup({\n        name: __privateGet(this, _name),\n        origin: __privateGet(this, _origin),\n        network: __privateGet(this, _network)\n      });\n      const tx = Transaction.from(await transaction.toJSON());\n      tx.setSenderIfNotSet(account.address);\n      const data = tx.serialize();\n      const response = await popup.send({\n        type: \"sign-transaction-block\",\n        data,\n        address: account.address\n      });\n      return {\n        bytes: response.bytes,\n        signature: response.signature\n      };\n    });\n    __privateAdd(this, _signPersonalMessage, async ({\n      message,\n      account\n    }) => {\n      const popup = new StashedPopup({\n        name: __privateGet(this, _name),\n        origin: __privateGet(this, _origin),\n        network: __privateGet(this, _network)\n      });\n      const bytes = toBase64(message);\n      const response = await popup.send({\n        type: \"sign-personal-message\",\n        bytes,\n        address: account.address\n      });\n      return {\n        bytes,\n        signature: response.signature\n      };\n    });\n    __privateAdd(this, _on, (event, listener) => {\n      __privateGet(this, _events).on(event, listener);\n      return () => __privateGet(this, _events).off(event, listener);\n    });\n    __privateAdd(this, _connect, async input => {\n      if (input?.silent) {\n        const address = localStorage.getItem(STASHED_RECENT_ADDRESS_KEY);\n        if (address) {\n          __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this, address);\n        }\n        return {\n          accounts: this.accounts\n        };\n      }\n      const popup = new StashedPopup({\n        name: __privateGet(this, _name),\n        origin: __privateGet(this, _origin),\n        network: __privateGet(this, _network)\n      });\n      const response = await popup.send({\n        type: \"connect\"\n      });\n      if (!(\"address\" in response)) {\n        throw new Error(\"Unexpected response\");\n      }\n      __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this, response.address);\n      return {\n        accounts: this.accounts\n      };\n    });\n    __privateAdd(this, _disconnect, async () => {\n      localStorage.removeItem(STASHED_RECENT_ADDRESS_KEY);\n      __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this);\n    });\n    __privateSet(this, _accounts, []);\n    __privateSet(this, _events, mitt());\n    __privateSet(this, _origin, origin);\n    __privateSet(this, _name, name);\n    __privateSet(this, _network, network);\n    if (address) {\n      __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this, address);\n    }\n  }\n  get name() {\n    return STASHED_WALLET_NAME;\n  }\n  get icon() {\n    return \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1NiIgaGVpZ2h0PSI1NiIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiB4PSIxIiB5PSIxIiBmaWxsPSIjNTE5REU5IiByeD0iMjciLz48cmVjdCB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHg9IjEiIHk9IjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiByeD0iMjciLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTguMzUzIDM1LjA2NGMuOTIxIDMuNDM4IDQuMzYzIDYuNTUxIDExLjQ4MyA0LjY0NCA2Ljc5NC0xLjgyMSAxMS4wNTItNy40MSA5Ljk0OC0xMS41My0uMzgxLTEuNDIzLTEuNTMtMi4zODctMy4zLTIuMjNsLTE1LjgzMiAxLjMyYy0uOTk3LjA3Ni0xLjQ1NC0uMDg4LTEuNzE4LS43MTYtLjI1Ni0uNTk5LS4xMS0xLjI0MSAxLjA5NC0xLjg1bDEyLjA0OC02LjE4M2MuOTI0LS40NyAxLjUzOS0uNjY2IDIuMTAxLS40NjguMzUyLjEyOC41ODQuNjM4LjM3MSAxLjI2N2wtLjc4MSAyLjMwNmMtLjk1OSAyLjgzIDEuMDk0IDMuNDg4IDIuMjUgMy4xNzggMS43NTEtLjQ2OSAyLjE2My0yLjEzNiAxLjU5OS00LjI0LTEuNDMtNS4zMzctNy4wOS02LjE3LTEyLjIyMy00Ljc5Ni01LjIyMiAxLjQtOS43NDggNS42My04LjM2NiAxMC43ODkuMzI1IDEuMjE1IDEuNDQ0IDIuMTg2IDIuNzQgMi4xNTdsMS45NzgtLjAwNWMuNDA3LS4wMS4yNi4wMjQgMS4wNDYtLjA0MS43ODQtLjA2NSAyLjg4LS4zMjMgMi44OC0uMzIzbDEwLjI4Ni0xLjE2NC4yNjUtLjAzOGMuNjAyLS4xMDMgMS4wNTYuMDUzIDEuNDQuNzE1LjU3Ni45OTEtLjMwMiAxLjczOC0xLjM1MiAyLjYzM2wtLjA4NS4wNzItOS4wNDEgNy43OTJjLTEuNTUgMS4zMzctMi42MzkuODM0LTMuMDItLjU4OWwtMS4zNS01LjA0Yy0uMzM0LTEuMjQ0LTEuNTUtMi4yMjEtMi45NzQtMS44NC0xLjc4LjQ3Ny0xLjkyNCAyLjU1LTEuNDg3IDQuMThaIi8+PC9zdmc+Cg==\";\n  }\n  get version() {\n    return \"1.0.0\";\n  }\n  get chains() {\n    return [SUI_MAINNET_CHAIN];\n  }\n  get accounts() {\n    return __privateGet(this, _accounts);\n  }\n  get features() {\n    return {\n      \"standard:connect\": {\n        version: \"1.0.0\",\n        connect: __privateGet(this, _connect)\n      },\n      \"standard:disconnect\": {\n        version: \"1.0.0\",\n        disconnect: __privateGet(this, _disconnect)\n      },\n      \"standard:events\": {\n        version: \"1.0.0\",\n        on: __privateGet(this, _on)\n      },\n      \"sui:signTransactionBlock\": {\n        version: \"1.0.0\",\n        signTransactionBlock: __privateGet(this, _signTransactionBlock)\n      },\n      \"sui:signTransaction\": {\n        version: \"2.0.0\",\n        signTransaction: __privateGet(this, _signTransaction)\n      },\n      \"sui:signPersonalMessage\": {\n        version: \"1.0.0\",\n        signPersonalMessage: __privateGet(this, _signPersonalMessage)\n      }\n    };\n  }\n}\n_events = new WeakMap();\n_accounts = new WeakMap();\n_origin = new WeakMap();\n_name = new WeakMap();\n_network = new WeakMap();\n_signTransactionBlock = new WeakMap();\n_signTransaction = new WeakMap();\n_signPersonalMessage = new WeakMap();\n_on = new WeakMap();\n_StashedWallet_instances = new WeakSet();\nsetAccount_fn = function (address) {\n  if (address) {\n    __privateSet(this, _accounts, [new ReadonlyWalletAccount({\n      address,\n      chains: [SUI_MAINNET_CHAIN],\n      features: [\"sui:signTransactionBlock\", \"sui:signPersonalMessage\"],\n      // NOTE: Stashed doesn't support getting public keys, and zkLogin accounts don't have meaningful public keys anyway\n      publicKey: new Uint8Array()\n    })]);\n    localStorage.setItem(STASHED_RECENT_ADDRESS_KEY, address);\n  } else {\n    __privateSet(this, _accounts, []);\n  }\n  __privateGet(this, _events).emit(\"change\", {\n    accounts: this.accounts\n  });\n};\n_connect = new WeakMap();\n_disconnect = new WeakMap();\nfunction registerStashedWallet(name, {\n  origin,\n  network = \"mainnet\"\n} = {}) {\n  const wallets = getWallets();\n  let addressFromRedirect = null;\n  try {\n    const params = new URLSearchParams(window.location.search);\n    addressFromRedirect = params.get(\"stashed_address\") || params.get(\"zksend_address\");\n  } catch {}\n  const wallet = new StashedWallet({\n    name,\n    network,\n    origin,\n    address: addressFromRedirect\n  });\n  const unregister = wallets.register(wallet);\n  return {\n    wallet,\n    unregister,\n    addressFromRedirect\n  };\n}\nexport { STASHED_WALLET_NAME, StashedWallet, registerStashedWallet };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}