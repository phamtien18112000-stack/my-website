{"ast":null,"code":"//#region src/storages/globalConfig/globalConfig.ts\nlet store$4;\n/**\n* Sets the global configuration.\n*\n* @param config The configuration.\n*/\nfunction setGlobalConfig(config$1) {\n  store$4 = {\n    ...store$4,\n    ...config$1\n  };\n}\n/**\n* Returns the global configuration.\n*\n* @param config The config to merge.\n*\n* @returns The configuration.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalConfig(config$1) {\n  return {\n    lang: config$1?.lang ?? store$4?.lang,\n    message: config$1?.message,\n    abortEarly: config$1?.abortEarly ?? store$4?.abortEarly,\n    abortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly\n  };\n}\n/**\n* Deletes the global configuration.\n*/\nfunction deleteGlobalConfig() {\n  store$4 = void 0;\n}\n\n//#endregion\n//#region src/storages/globalMessage/globalMessage.ts\nlet store$3;\n/**\n* Sets a global error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setGlobalMessage(message$1, lang) {\n  if (!store$3) store$3 = /* @__PURE__ */new Map();\n  store$3.set(lang, message$1);\n}\n/**\n* Returns a global error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalMessage(lang) {\n  return store$3?.get(lang);\n}\n/**\n* Deletes a global error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteGlobalMessage(lang) {\n  store$3?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/schemaMessage/schemaMessage.ts\nlet store$2;\n/**\n* Sets a schema error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSchemaMessage(message$1, lang) {\n  if (!store$2) store$2 = /* @__PURE__ */new Map();\n  store$2.set(lang, message$1);\n}\n/**\n* Returns a schema error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSchemaMessage(lang) {\n  return store$2?.get(lang);\n}\n/**\n* Deletes a schema error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteSchemaMessage(lang) {\n  store$2?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/specificMessage/specificMessage.ts\nlet store$1;\n/**\n* Sets a specific error message.\n*\n* @param reference The identifier reference.\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSpecificMessage(reference, message$1, lang) {\n  if (!store$1) store$1 = /* @__PURE__ */new Map();\n  if (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */new Map());\n  store$1.get(reference).set(lang, message$1);\n}\n/**\n* Returns a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSpecificMessage(reference, lang) {\n  return store$1?.get(reference)?.get(lang);\n}\n/**\n* Deletes a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*/\nfunction deleteSpecificMessage(reference, lang) {\n  store$1?.get(reference)?.delete(lang);\n}\n\n//#endregion\n//#region src/utils/_stringify/_stringify.ts\n/**\n* Stringifies an unknown input to a literal or type string.\n*\n* @param input The unknown input.\n*\n* @returns A literal or type string.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") return `\"${input}\"`;\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") return `${input}`;\n  if (type === \"object\" || type === \"function\") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  return type;\n}\n\n//#endregion\n//#region src/utils/_addIssue/_addIssue.ts\n/**\n* Adds an issue to the dataset.\n*\n* @param context The issue context.\n* @param label The issue label.\n* @param dataset The input dataset.\n* @param config The configuration.\n* @param other The optional props.\n*\n* @internal\n*/\nfunction _addIssue(context, label, dataset, config$1, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? /* @__PURE__ */_stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config$1.lang,\n    abortEarly: config$1.abortEarly,\n    abortPipeEarly: config$1.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message$1 = other?.message ?? context.message ?? /* @__PURE__ */getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */getGlobalMessage(issue.lang);\n  if (message$1 !== void 0) issue.message = typeof message$1 === \"function\" ? message$1(issue) : message$1;\n  if (isSchema) dataset.typed = false;\n  if (dataset.issues) dataset.issues.push(issue);else dataset.issues = [issue];\n}\n\n//#endregion\n//#region src/utils/_getByteCount/_getByteCount.ts\nlet textEncoder;\n/**\n* Returns the byte count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The byte count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getByteCount(input) {\n  if (!textEncoder) textEncoder = new TextEncoder();\n  return textEncoder.encode(input).length;\n}\n\n//#endregion\n//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts\nlet segmenter;\n/**\n* Returns the grapheme count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The grapheme count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getGraphemeCount(input) {\n  if (!segmenter) segmenter = new Intl.Segmenter();\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) count++;\n  return count;\n}\n\n//#endregion\n//#region src/utils/_getLastMetadata/_getLastMetadata.ts\n/**\n* Returns the last top-level value of a given metadata type from a schema\n* using a breadth-first search that starts with the last item in the pipeline.\n*\n* @param schema The schema to search.\n* @param type The metadata type.\n*\n* @returns The value, if any.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getLastMetadata(schema, type) {\n  if (\"pipe\" in schema) {\n    const nestedSchemas = [];\n    for (let index = schema.pipe.length - 1; index >= 0; index--) {\n      const item = schema.pipe[index];\n      if (item.kind === \"schema\" && \"pipe\" in item) nestedSchemas.push(item);else if (item.kind === \"metadata\" && item.type === type) return item[type];\n    }\n    for (const nestedSchema of nestedSchemas) {\n      const result = /* @__PURE__ */_getLastMetadata(nestedSchema, type);\n      if (result !== void 0) return result;\n    }\n  }\n}\n\n//#endregion\n//#region src/utils/_getStandardProps/_getStandardProps.ts\n/**\n* Returns the Standard Schema properties.\n*\n* @param context The schema context.\n*\n* @returns The Standard Schema properties.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value$1) {\n      return context[\"~run\"]({\n        value: value$1\n      }, /* @__PURE__ */getGlobalConfig());\n    }\n  };\n}\n\n//#endregion\n//#region src/utils/_getWordCount/_getWordCount.ts\nlet store;\n/**\n* Returns the word count of the input.\n*\n* @param locales The locales to be used.\n* @param input The input to be measured.\n*\n* @returns The word count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getWordCount(locales, input) {\n  if (!store) store = /* @__PURE__ */new Map();\n  if (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, {\n    granularity: \"word\"\n  }));\n  const segments = store.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) if (segment.isWordLike) count++;\n  return count;\n}\n\n//#endregion\n//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\n/**\n* Non-digit regex.\n*/\nconst NON_DIGIT_REGEX = /\\D/gu;\n/**\n* Checks whether a string with numbers corresponds to the luhn algorithm.\n*\n* @param input The input to be checked.\n*\n* @returns Whether input is valid.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isLuhnAlgo(input) {\n  const number$1 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length$1 = number$1.length;\n  let bit = 1;\n  let sum = 0;\n  while (length$1) {\n    const value$1 = +number$1[--length$1];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value$1] : value$1;\n  }\n  return sum % 10 === 0;\n}\n\n//#endregion\n//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts\n/**\n* Disallows inherited object properties and prevents object prototype\n* pollution by disallowing certain keys.\n*\n* @param object The object to check.\n* @param key The key to check.\n*\n* @returns Whether the key is allowed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isValidObjectKey(object$1, key) {\n  return Object.hasOwn(object$1, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n//#endregion\n//#region src/utils/_joinExpects/_joinExpects.ts\n/**\n* Joins multiple `expects` values with the given separator.\n*\n* @param values The `expects` values.\n* @param separator The separator.\n*\n* @returns The joined `expects` property.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _joinExpects(values$1, separator) {\n  const list = [...new Set(values$1)];\n  if (list.length > 1) return `(${list.join(` ${separator} `)})`;\n  return list[0] ?? \"never\";\n}\n\n//#endregion\n//#region src/utils/entriesFromList/entriesFromList.ts\n/**\n* Creates an object entries definition from a list of keys and a schema.\n*\n* @param list A list of keys.\n* @param schema The schema of the keys.\n*\n* @returns The object entries.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromList(list, schema) {\n  const entries$1 = {};\n  for (const key of list) entries$1[key] = schema;\n  return entries$1;\n}\n\n//#endregion\n//#region src/utils/entriesFromObjects/entriesFromObjects.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromObjects(schemas) {\n  const entries$1 = {};\n  for (const schema of schemas) Object.assign(entries$1, schema.entries);\n  return entries$1;\n}\n\n//#endregion\n//#region src/utils/getDotPath/getDotPath.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n      if (key) key += `.${item.key}`;else key += item.key;\n    } else return null;\n    return key;\n  }\n  return null;\n}\n\n//#endregion\n//#region src/utils/isOfKind/isOfKind.ts\n/**\n* A generic type guard to check the kind of an object.\n*\n* @param kind The kind to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfKind(kind, object$1) {\n  return object$1.kind === kind;\n}\n\n//#endregion\n//#region src/utils/isOfType/isOfType.ts\n/**\n* A generic type guard to check the type of an object.\n*\n* @param type The type to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfType(type, object$1) {\n  return object$1.type === type;\n}\n\n//#endregion\n//#region src/utils/isValiError/isValiError.ts\n/**\n* A type guard to check if an error is a ValiError.\n*\n* @param error The error to check.\n*\n* @returns Whether its a ValiError.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n//#endregion\n//#region src/utils/ValiError/ValiError.ts\n/**\n* A Valibot error with useful information.\n*/\nvar ValiError = class extends Error {\n  /**\n  * Creates a Valibot error with useful information.\n  *\n  * @param issues The error issues.\n  */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n//#endregion\n//#region src/actions/args/args.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config$1) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({\n          value: args_\n        }, config$1);\n        if (argsDataset.issues) throw new ValiError(argsDataset.issues);\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/args/argsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config$1) {\n      const func = dataset.value;\n      dataset.value = async (...args$1) => {\n        const argsDataset = await schema[\"~run\"]({\n          value: args$1\n        }, config$1);\n        if (argsDataset.issues) throw new ValiError(argsDataset.issues);\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/await/awaitAsync.ts\n/**\n* Creates an await transformation action.\n*\n* @returns An await action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/regex.ts\n/**\n* [Base64](https://en.wikipedia.org/wiki/Base64) regex.\n*/\nconst BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\n/**\n* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.\n*/\nconst BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\n/**\n* [Cuid2](https://github.com/paralleldrive/cuid2) regex.\n*/\nconst CUID2_REGEX = /^[a-z][\\da-z]*$/u;\n/**\n* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.\n*/\nconst DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\n/**\n* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.\n*/\nconst DIGITS_REGEX = /^\\d+$/u;\n/**\n* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.\n*/\nconst EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\n/**\n* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).\n*\n* Hint: We decided against the newer `/^\\p{RGI_Emoji}+$/v` regex because it is\n* not supported in older runtimes and does not match all emoji.\n*/\nconst EMOJI_REGEX = /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$/u;\n/**\n* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\n/**\n* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\n/**\n* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.\n*/\nconst IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\n/**\n* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.\n*/\nconst IPV4_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\n/**\n* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.\n*/\nconst IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [IP](https://en.wikipedia.org/wiki/IP_address) regex.\n*/\nconst IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.\n*/\nconst ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.\n*/\nconst ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.\n*/\nconst ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.\n*/\nconst ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.\n*/\nconst ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.\n*/\nconst ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.\n*/\nconst MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.\n*/\nconst MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.\n*/\nconst MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [Nano ID](https://github.com/ai/nanoid) regex.\n*/\nconst NANO_ID_REGEX = /^[\\w-]+$/u;\n/**\n* [Octal](https://en.wikipedia.org/wiki/Octal) regex.\n*/\nconst OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\n/**\n* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.\n*\n* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.\n*/\nconst RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.\n*/\nconst SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\n/**\n* [ULID](https://github.com/ulid/spec) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\n/**\n* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.\n*/\nconst UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n//#endregion\n//#region src/actions/base64/base64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction base64(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Base64\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/bic/bic.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bic(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"BIC\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/brand/brand.ts\n/**\n* Creates a brand transformation action.\n*\n* @param name The brand name.\n*\n* @returns A brand action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/bytes/bytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bytes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const length$1 = /* @__PURE__ */_getByteCount(dataset.value);\n        if (length$1 !== this.requirement) _addIssue(this, \"bytes\", dataset, config$1, {\n          received: `${length$1}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/check/check.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction check(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/check/checkAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkAsync(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message: message$1,\n    async \"~run\"(dataset, config$1) {\n      if (dataset.typed && !(await this.requirement(dataset.value))) _addIssue(this, \"input\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItems(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {\n        const item = dataset.value[index];\n        if (!this.requirement(item, index, dataset.value)) _addIssue(this, \"item\", dataset, config$1, {\n          input: item,\n          path: [{\n            type: \"array\",\n            origin: \"value\",\n            input: dataset.value,\n            key: index,\n            value: item\n          }]\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItemsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItemsAsync(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message: message$1,\n    async \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(dataset.value.map(this.requirement));\n        for (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {\n          const item = dataset.value[index];\n          _addIssue(this, \"item\", dataset, config$1, {\n            input: item,\n            path: [{\n              type: \"array\",\n              origin: \"value\",\n              input: dataset.value,\n              key: index,\n              value: item\n            }]\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/creditCard/creditCard.ts\n/**\n* Credit card regex.\n*/\nconst CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n/**\n* Sanitize regex.\n*/\nconst SANITIZE_REGEX = /[- ]/gu;\n/**\n* Provider regex list.\n*/\nconst PROVIDER_REGEX_LIST = [/^3[47]\\d{13}$/u, /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u, /^6(?:011|5\\d{2})\\d{12,15}$/u, /^(?:2131|1800|35\\d{3})\\d{11}$/u, /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u, /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u, /^4\\d{12}(?:\\d{3,6})?$/u];\n/* @__NO_SIDE_EFFECTS__ */\nfunction creditCard(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, \"\")) && PROVIDER_REGEX_LIST.some(regex$1 => regex$1.test(sanitized)) && /* @__PURE__ */_isLuhnAlgo(sanitized);\n    },\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"credit card\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/cuid2/cuid2.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction cuid2(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Cuid2\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/decimal/decimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction decimal(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"decimal\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/description/description.ts\n/**\n* Creates a description metadata action.\n*\n* @param description_ The description text.\n*\n* @returns A description action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n//#endregion\n//#region src/actions/digits/digits.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction digits(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"digits\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/email/email.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction email(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/emoji/emoji.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction emoji(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"emoji\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/empty/empty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction empty(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.length > 0) _addIssue(this, \"length\", dataset, config$1, {\n        received: `${dataset.value.length}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/endsWith/endsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction endsWith(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, \"end\", dataset, config$1, {\n        received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/entries/entries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entries(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"entries\",\n    reference: entries,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count !== this.requirement) _addIssue(this, \"entries\", dataset, config$1, {\n        received: `${count}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/everyItem/everyItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction everyItem(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/examples/examples.ts\n/**\n* Creates an examples metadata action.\n*\n* @param examples_ The examples.\n*\n* @returns An examples action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction examples(examples_) {\n  return {\n    kind: \"metadata\",\n    type: \"examples\",\n    reference: examples,\n    examples: examples_\n  };\n}\n\n//#endregion\n//#region src/actions/excludes/excludes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction excludes(requirement, message$1) {\n  const received = /* @__PURE__ */_stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, {\n        received\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/filterItems/filterItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/findItem/findItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/finite/finite.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction finite(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"finite\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/flavor/flavor.ts\n/**\n* Creates a flavor transformation action.\n*\n* @param name The flavor name.\n*\n* @returns A flavor action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction flavor(name) {\n  return {\n    kind: \"transformation\",\n    type: \"flavor\",\n    reference: flavor,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/graphemes/graphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction graphemes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getGraphemeCount(dataset.value);\n        if (count !== this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/gtValue/gtValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction gtValue(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"gt_value\",\n    reference: gtValue,\n    async: false,\n    expects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */_stringify(requirement)}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/hash/hash.ts\n/**\n* Hash lengths object.\n*/\nconst HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n/* @__NO_SIDE_EFFECTS__ */\nfunction hash(types, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(types.map(type => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hash\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/hexadecimal/hexadecimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexadecimal(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hexadecimal\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/hexColor/hexColor.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexColor(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hex color\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/imei/imei.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction imei(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && /* @__PURE__ */_isLuhnAlgo(input);\n    },\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"IMEI\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/includes/includes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction includes(requirement, message$1) {\n  const expects = /* @__PURE__ */_stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, {\n        received: `!${expects}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/integer/integer.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction integer(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"integer\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/ip/ip.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ip(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IP\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/ipv4/ipv4.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv4(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv4\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/ipv6/ipv6.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv6(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv6\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/isoDate/isoDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDate(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/isoDateTime/isoDateTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDateTime(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date-time\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/isoTime/isoTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTime(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/isoTimeSecond/isoTimeSecond.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimeSecond(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time-second\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/isoTimestamp/isoTimestamp.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimestamp(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"timestamp\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/isoWeek/isoWeek.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoWeek(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"week\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/length/length.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction length(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, \"length\", dataset, config$1, {\n        received: `${dataset.value.length}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/ltValue/ltValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ltValue(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"lt_value\",\n    reference: ltValue,\n    async: false,\n    expects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */_stringify(requirement)}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/mac/mac.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"MAC\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/mac48/mac48.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac48(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"48-bit MAC\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/mac64/mac64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac64(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"64-bit MAC\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/mapItems/mapItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/maxBytes/maxBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxBytes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const length$1 = /* @__PURE__ */_getByteCount(dataset.value);\n        if (length$1 > this.requirement) _addIssue(this, \"bytes\", dataset, config$1, {\n          received: `${length$1}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/maxEntries/maxEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxEntries(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"max_entries\",\n    reference: maxEntries,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count > this.requirement) _addIssue(this, \"entries\", dataset, config$1, {\n        received: `${count}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/maxGraphemes/maxGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxGraphemes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getGraphemeCount(dataset.value);\n        if (count > this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/maxLength/maxLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxLength(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, \"length\", dataset, config$1, {\n        received: `${dataset.value.length}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/maxSize/maxSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxSize(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, \"size\", dataset, config$1, {\n        received: `${dataset.value.size}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/maxValue/maxValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxValue(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */_stringify(requirement)}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/maxWords/maxWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxWords(locales, requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) _addIssue(this, \"words\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/metadata/metadata.ts\n/**\n* Creates a custom metadata action.\n*\n* @param metadata_ The metadata object.\n*\n* @returns A metadata action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n//#endregion\n//#region src/actions/mimeType/mimeType.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mimeType(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: /* @__PURE__ */_joinExpects(requirement.map(option => `\"${option}\"`), \"|\"),\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, \"MIME type\", dataset, config$1, {\n        received: `\"${dataset.value.type}\"`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/minBytes/minBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minBytes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const length$1 = /* @__PURE__ */_getByteCount(dataset.value);\n        if (length$1 < this.requirement) _addIssue(this, \"bytes\", dataset, config$1, {\n          received: `${length$1}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/minEntries/minEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minEntries(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"min_entries\",\n    reference: minEntries,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count < this.requirement) _addIssue(this, \"entries\", dataset, config$1, {\n        received: `${count}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/minGraphemes/minGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minGraphemes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getGraphemeCount(dataset.value);\n        if (count < this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/minLength/minLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minLength(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, \"length\", dataset, config$1, {\n        received: `${dataset.value.length}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/minSize/minSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minSize(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, \"size\", dataset, config$1, {\n        received: `${dataset.value.size}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/minValue/minValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minValue(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */_stringify(requirement)}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/minWords/minWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minWords(locales, requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) _addIssue(this, \"words\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/multipleOf/multipleOf.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction multipleOf(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, \"multiple\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/nanoid/nanoid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nanoid(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Nano ID\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/nonEmpty/nonEmpty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonEmpty(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.length === 0) _addIssue(this, \"length\", dataset, config$1, {\n        received: \"0\"\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/normalize/normalize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notBytes/notBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notBytes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const length$1 = /* @__PURE__ */_getByteCount(dataset.value);\n        if (length$1 === this.requirement) _addIssue(this, \"bytes\", dataset, config$1, {\n          received: `${length$1}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notEntries/notEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notEntries(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_entries\",\n    reference: notEntries,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count === this.requirement) _addIssue(this, \"entries\", dataset, config$1, {\n        received: `${count}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notGraphemes/notGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notGraphemes(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getGraphemeCount(dataset.value);\n        if (count === this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notLength/notLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notLength(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, \"length\", dataset, config$1, {\n        received: `${dataset.value.length}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notSize/notSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notSize(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, \"size\", dataset, config$1, {\n        received: `${dataset.value.size}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notValue/notValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValue(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */_stringify(requirement)}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notValues/notValues.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValues(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_values\",\n    reference: notValues,\n    async: false,\n    expects: `!${/* @__PURE__ */_joinExpects(requirement.map(value$1 => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */_stringify(value$1)), \"|\")}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && this.requirement.some(value$1 => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/notWords/notWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notWords(locales, requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) _addIssue(this, \"words\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/octal/octal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction octal(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"octal\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/parseJson/parseJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parseJson(config$1, message$1) {\n  return {\n    kind: \"transformation\",\n    type: \"parse_json\",\n    reference: parseJson,\n    config: config$1,\n    message: message$1,\n    async: false,\n    \"~run\"(dataset, config$2) {\n      try {\n        dataset.value = JSON.parse(dataset.value, this.config?.reviver);\n      } catch (error) {\n        if (error instanceof Error) {\n          _addIssue(this, \"JSON\", dataset, config$2, {\n            received: `\"${error.message}\"`\n          });\n          dataset.typed = false;\n        } else throw error;\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n/**\n* Checks if a dataset is partially typed.\n*\n* @param dataset The dataset to check.\n* @param paths The paths to check.\n*\n* @returns Whether it is partially typed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isPartiallyTyped(dataset, paths) {\n  if (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {\n    let typed = false;\n    const bound = Math.min(path.length, issue.path?.length ?? 0);\n    for (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n      typed = true;\n      break;\n    }\n    if (!typed) return false;\n  }\n  return true;\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheck.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheck(paths, requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    paths,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if ((dataset.typed || /* @__PURE__ */_isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheckAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheckAsync(paths, requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    paths,\n    requirement,\n    message: message$1,\n    async \"~run\"(dataset, config$1) {\n      if ((dataset.typed || /* @__PURE__ */_isPartiallyTyped(dataset, paths)) && !(await this.requirement(dataset.value))) _addIssue(this, \"input\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheck.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config$1) {\n      action({\n        dataset,\n        config: config$1,\n        addIssue: info => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheckAsync.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config$1) {\n      await action({\n        dataset,\n        config: config$1,\n        addIssue: info => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransform.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config$1) {\n      const output = action({\n        dataset,\n        config: config$1,\n        addIssue: info => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n        NEVER: null\n      });\n      if (dataset.issues) dataset.typed = false;else dataset.value = output;\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransformAsync.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config$1) {\n      const output = await action({\n        dataset,\n        config: config$1,\n        addIssue: info => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n        NEVER: null\n      });\n      if (dataset.issues) dataset.typed = false;else dataset.value = output;\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/readonly/readonly.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/reduceItems/reduceItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/regex/regex.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction regex(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"format\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/returns/returns.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config$1) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"]({\n          value: func(...args_)\n        }, config$1);\n        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/returns/returnsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config$1) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"]({\n          value: await func(...args_)\n        }, config$1);\n        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/rfcEmail/rfcEmail.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction rfcEmail(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/safeInteger/safeInteger.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeInteger(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"safe integer\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/size/size.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction size(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, \"size\", dataset, config$1, {\n        received: `${dataset.value.size}`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/slug/slug.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction slug(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"slug\",\n    reference: slug,\n    async: false,\n    expects: null,\n    requirement: SLUG_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"slug\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/someItem/someItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction someItem(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/sortItems/sortItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/startsWith/startsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction startsWith(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, \"start\", dataset, config$1, {\n        received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/stringifyJson/stringifyJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction stringifyJson(config$1, message$1) {\n  return {\n    kind: \"transformation\",\n    type: \"stringify_json\",\n    reference: stringifyJson,\n    message: message$1,\n    config: config$1,\n    async: false,\n    \"~run\"(dataset, config$2) {\n      try {\n        const output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);\n        if (output === void 0) {\n          _addIssue(this, \"JSON\", dataset, config$2);\n          dataset.typed = false;\n        }\n        dataset.value = output;\n      } catch (error) {\n        if (error instanceof Error) {\n          _addIssue(this, \"JSON\", dataset, config$2, {\n            received: `\"${error.message}\"`\n          });\n          dataset.typed = false;\n        } else throw error;\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/title/title.ts\n/**\n* Creates a title metadata action.\n*\n* @param title_ The title text.\n*\n* @returns A title action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n//#endregion\n//#region src/actions/toBigint/toBigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBigint(message$1) {\n  return {\n    kind: \"transformation\",\n    type: \"to_bigint\",\n    reference: toBigint,\n    async: false,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      try {\n        dataset.value = BigInt(dataset.value);\n      } catch {\n        _addIssue(this, \"bigint\", dataset, config$1);\n        dataset.typed = false;\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toBoolean/toBoolean.ts\n/**\n* Creates a to boolean transformation action.\n*\n* @returns A to boolean action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBoolean() {\n  return {\n    kind: \"transformation\",\n    type: \"to_boolean\",\n    reference: toBoolean,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = Boolean(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toDate/toDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toDate(message$1) {\n  return {\n    kind: \"transformation\",\n    type: \"to_date\",\n    reference: toDate,\n    async: false,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      try {\n        dataset.value = new Date(dataset.value);\n        if (isNaN(dataset.value)) {\n          _addIssue(this, \"date\", dataset, config$1, {\n            received: \"\\\"Invalid Date\\\"\"\n          });\n          dataset.typed = false;\n        }\n      } catch {\n        _addIssue(this, \"date\", dataset, config$1);\n        dataset.typed = false;\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toLowerCase/toLowerCase.ts\n/**\n* Creates a to lower case transformation action.\n*\n* @returns A to lower case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toMaxValue/toMaxValue.ts\n/**\n* Creates a to max value transformation action.\n*\n* @param requirement The maximum value.\n*\n* @returns A to max value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toMinValue/toMinValue.ts\n/**\n* Creates a to min value transformation action.\n*\n* @param requirement The minimum value.\n*\n* @returns A to min value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toNumber/toNumber.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toNumber(message$1) {\n  return {\n    kind: \"transformation\",\n    type: \"to_number\",\n    reference: toNumber,\n    async: false,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      try {\n        dataset.value = Number(dataset.value);\n        if (isNaN(dataset.value)) {\n          _addIssue(this, \"number\", dataset, config$1);\n          dataset.typed = false;\n        }\n      } catch {\n        _addIssue(this, \"number\", dataset, config$1);\n        dataset.typed = false;\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toString/toString.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toString(message$1) {\n  return {\n    kind: \"transformation\",\n    type: \"to_string\",\n    reference: toString,\n    async: false,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      try {\n        dataset.value = String(dataset.value);\n      } catch {\n        _addIssue(this, \"string\", dataset, config$1);\n        dataset.typed = false;\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/toUpperCase/toUpperCase.ts\n/**\n* Creates a to upper case transformation action.\n*\n* @returns A to upper case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/transform/transform.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/transform/transformAsync.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/trim/trim.ts\n/**\n* Creates a trim transformation action.\n*\n* @returns A trim action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/trimEnd/trimEnd.ts\n/**\n* Creates a trim end transformation action.\n*\n* @returns A trim end action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/trimStart/trimStart.ts\n/**\n* Creates a trim start transformation action.\n*\n* @returns A trim start action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/ulid/ulid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ulid(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"ULID\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/url/url.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction url(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"URL\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/uuid/uuid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction uuid(message$1) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"UUID\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/value/value.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction value(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */_stringify(requirement),\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/values/values.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction values(requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"values\",\n    reference: values,\n    async: false,\n    expects: `${/* @__PURE__ */_joinExpects(requirement.map(value$1 => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */_stringify(value$1)), \"|\")}`,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed && !this.requirement.some(value$1 => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, {\n        received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */_stringify(dataset.value)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/actions/words/words.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction words(locales, requirement, message$1) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message: message$1,\n    \"~run\"(dataset, config$1) {\n      if (dataset.typed) {\n        const count = /* @__PURE__ */_getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) _addIssue(this, \"words\", dataset, config$1, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/assert/assert.ts\n/**\n* Checks if the input matches the schema. As this is an assertion function, it\n* can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*/\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({\n    value: input\n  }, {\n    abortEarly: true\n  }).issues;\n  if (issues) throw new ValiError(issues);\n}\n\n//#endregion\n//#region src/methods/config/config.ts\n/**\n* Changes the local configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param config The parse configuration.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction config(schema, config$1) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, {\n        ...config_,\n        ...config$1\n      });\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/getFallback/getFallback.ts\n/**\n* Returns the fallback value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The output dataset if available.\n* @param config The config if available.\n*\n* @returns The fallback value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallback(schema, dataset, config$1) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(dataset, config$1) : schema.fallback;\n}\n\n//#endregion\n//#region src/methods/fallback/fallback.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallback(schema, fallback$1) {\n  return {\n    ...schema,\n    fallback: fallback$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const outputDataset = schema[\"~run\"](dataset, config$1);\n      return outputDataset.issues ? {\n        typed: true,\n        value: /* @__PURE__ */getFallback(this, outputDataset, config$1)\n      } : outputDataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/fallback/fallbackAsync.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallbackAsync(schema, fallback$1) {\n  return {\n    ...schema,\n    fallback: fallback$1,\n    async: true,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const outputDataset = await schema[\"~run\"](dataset, config$1);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await /* @__PURE__ */getFallback(this, outputDataset, config$1)\n      } : outputDataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/flatten/flatten.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) if (issue.path) {\n    const dotPath = /* @__PURE__ */getDotPath(issue);\n    if (dotPath) {\n      if (!flatErrors.nested) flatErrors.nested = {};\n      if (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);else flatErrors.nested[dotPath] = [issue.message];\n    } else if (flatErrors.other) flatErrors.other.push(issue.message);else flatErrors.other = [issue.message];\n  } else if (flatErrors.root) flatErrors.root.push(issue.message);else flatErrors.root = [issue.message];\n  return flatErrors;\n}\n\n//#endregion\n//#region src/methods/forward/forward.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forward(action, path) {\n  return {\n    ...action,\n    \"~run\"(dataset, config$1) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config$1);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n          let pathInput = dataset.value;\n          for (const key of path) {\n            const pathValue = pathInput[key];\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            if (issue.path) issue.path.push(pathItem);else issue.path = [pathItem];\n            if (!pathValue) break;\n            pathInput = pathValue;\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/forward/forwardAsync.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forwardAsync(action, path) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config$1) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config$1);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n          let pathInput = dataset.value;\n          for (const key of path) {\n            const pathValue = pathInput[key];\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            if (issue.path) issue.path.push(pathItem);else issue.path = [pathItem];\n            if (!pathValue) break;\n            pathInput = pathValue;\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/getDefault/getDefault.ts\n/**\n* Returns the default value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The input dataset if available.\n* @param config The config if available.\n*\n* @returns The default value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefault(schema, dataset, config$1) {\n  return typeof schema.default === \"function\" ? schema.default(dataset, config$1) : schema.default;\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaults.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object$1 = {};\n    for (const key in schema.entries) object$1[key] = /* @__PURE__ */getDefaults(schema.entries[key]);\n    return object$1;\n  }\n  if (\"items\" in schema) return schema.items.map(getDefaults);\n  return /* @__PURE__ */getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaultsAsync.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */getDefaultsAsync(value$1)])));\n  if (\"items\" in schema) return Promise.all(schema.items.map(getDefaultsAsync));\n  return /* @__PURE__ */getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDescription/getDescription.ts\n/**\n* Returns the description of the schema.\n*\n* If multiple descriptions are defined, the last one of the highest level is\n* returned. If no description is defined, `undefined` is returned.\n*\n* @param schema The schema to get the description from.\n*\n* @returns The description, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDescription(schema) {\n  return /* @__PURE__ */_getLastMetadata(schema, \"description\");\n}\n\n//#endregion\n//#region src/methods/getExamples/getExamples.ts\n/**\n* Returns the examples of a schema.\n*\n* If multiple examples are defined, it concatenates them using depth-first\n* search. If no examples are defined, an empty array is returned.\n*\n* @param schema The schema to get the examples from.\n*\n* @returns The examples, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getExamples(schema) {\n  const examples$1 = [];\n  function depthFirstCollect(schema$1) {\n    if (\"pipe\" in schema$1) {\n      for (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstCollect(item);else if (item.kind === \"metadata\" && item.type === \"examples\") examples$1.push(...item.examples);\n    }\n  }\n  depthFirstCollect(schema);\n  return examples$1;\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacks.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object$1 = {};\n    for (const key in schema.entries) object$1[key] = /* @__PURE__ */getFallbacks(schema.entries[key]);\n    return object$1;\n  }\n  if (\"items\" in schema) return schema.items.map(getFallbacks);\n  return /* @__PURE__ */getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacksAsync.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */getFallbacksAsync(value$1)])));\n  if (\"items\" in schema) return Promise.all(schema.items.map(getFallbacksAsync));\n  return /* @__PURE__ */getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getMetadata/getMetadata.ts\n/**\n* Returns the metadata of a schema.\n*\n* If multiple metadata are defined, it shallowly merges them using depth-first\n* search. If no metadata is defined, an empty object is returned.\n*\n* @param schema Schema to get the metadata from.\n*\n* @returns The metadata, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getMetadata(schema) {\n  const result = {};\n  function depthFirstMerge(schema$1) {\n    if (\"pipe\" in schema$1) {\n      for (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstMerge(item);else if (item.kind === \"metadata\" && item.type === \"metadata\") Object.assign(result, item.metadata);\n    }\n  }\n  depthFirstMerge(schema);\n  return result;\n}\n\n//#endregion\n//#region src/methods/getTitle/getTitle.ts\n/**\n* Returns the title of the schema.\n*\n* If multiple titles are defined, the last one of the highest level is\n* returned. If no title is defined, `undefined` is returned.\n*\n* @param schema The schema to get the title from.\n*\n* @returns The title, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getTitle(schema) {\n  return /* @__PURE__ */_getLastMetadata(schema, \"title\");\n}\n\n//#endregion\n//#region src/methods/is/is.ts\n/**\n* Checks if the input matches the schema. By using a type predicate, this\n* function can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*\n* @returns Whether the input matches the schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction is(schema, input) {\n  return !schema[\"~run\"]({\n    value: input\n  }, {\n    abortEarly: true\n  }).issues;\n}\n\n//#endregion\n//#region src/schemas/any/any.ts\n/**\n* Creates an any schema.\n*\n* Hint: This schema function exists only for completeness and is not\n* recommended in practice. Instead, `unknown` should be used to accept\n* unknown data.\n*\n* @returns An any schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/array/array.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction array(item, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value$1 = input[key];\n          const itemDataset = this.item[\"~run\"]({\n            value: value$1\n          }, config$1);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/array/arrayAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction arrayAsync(item, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(input.map(value$1 => this.item[\"~run\"]({\n          value: value$1\n        }, config$1)));\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/bigint/bigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bigint(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (typeof dataset.value === \"bigint\") dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/blob/blob.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction blob(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value instanceof Blob) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/boolean/boolean.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction boolean(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (typeof dataset.value === \"boolean\") dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/custom/custom.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction custom(check$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (this.check(dataset.value)) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/custom/customAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction customAsync(check$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (await this.check(dataset.value)) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/date/date.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction date(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1, {\n          received: \"\\\"Invalid Date\\\"\"\n        });\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/enum/enum.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction enum_(enum__, message$1) {\n  const options = [];\n  for (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: /* @__PURE__ */_joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (this.options.includes(dataset.value)) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/file/file.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction file(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value instanceof File) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/function/function.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction function_(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (typeof dataset.value === \"function\") dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/instance/instance.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction instance(class_, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value instanceof this.class) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/intersect/utils/_merge/_merge.ts\n/**\n* Merges two values into one single output.\n*\n* @param value1 First value.\n* @param value2 Second value.\n*\n* @returns The merge dataset.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return {\n      value: value1\n    };\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) if (key in value1) {\n        const dataset = /* @__PURE__ */_merge(value1[key], value2[key]);\n        if (dataset.issue) return dataset;\n        value1[key] = dataset.value;\n      } else value1[key] = value2[key];\n      return {\n        value: value1\n      };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */_merge(value1[index], value2[index]);\n          if (dataset.issue) return dataset;\n          value1[index] = dataset.value;\n        }\n        return {\n          value: value1\n        };\n      }\n    }\n  }\n  return {\n    issue: true\n  };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersect.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersect(options, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: /* @__PURE__ */_joinExpects(options.map(option => option.expects), \"&\"),\n    async: false,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({\n            value: input\n          }, config$1);\n          if (optionDataset.issues) {\n            if (dataset.issues) dataset.issues.push(...optionDataset.issues);else dataset.issues = optionDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) dataset.typed = false;\n          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);else outputs = [optionDataset.value];\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = /* @__PURE__ */_merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config$1, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersectAsync(options, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: /* @__PURE__ */_joinExpects(options.map(option => option.expects), \"&\"),\n    async: true,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(this.options.map(schema => schema[\"~run\"]({\n          value: input\n        }, config$1)));\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) dataset.issues.push(...optionDataset.issues);else dataset.issues = optionDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) dataset.typed = false;\n          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);else outputs = [optionDataset.value];\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = /* @__PURE__ */_merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config$1, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/lazy/lazy.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/lazy/lazyAsync.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/literal/literal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction literal(literal_, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: /* @__PURE__ */_stringify(literal_),\n    async: false,\n    literal: literal_,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === this.literal) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObject(entries$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries: entries$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : /* @__PURE__ */getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value$1\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) dataset.issues = valueDataset.issues;\n              if (config$1.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) dataset.typed = false;\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config$1, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [{\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key,\n                value: input[key]\n              }]\n            });\n            if (config$1.abortEarly) break;\n          }\n        }\n        if (!dataset.issues || !config$1.abortEarly) {\n          for (const key in input) if (/* @__PURE__ */_isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObjectAsync(entries$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : await /* @__PURE__ */getDefault(valueSchema);\n            return [key, value$1, valueSchema, await valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1)];\n          }\n          return [key, input[key], valueSchema, null];\n        }));\n        for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) dataset.typed = false;\n          dataset.value[key] = valueDataset.value;\n        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n          _addIssue(this, \"key\", dataset, config$1, {\n            input: void 0,\n            expected: `\"${key}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key,\n              value: value$1\n            }]\n          });\n          if (config$1.abortEarly) break;\n        }\n        if (!dataset.issues || !config$1.abortEarly) {\n          for (const key in input) if (/* @__PURE__ */_isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTuple(items, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value$1 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({\n            value: value$1\n          }, config$1);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTupleAsync(items, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n          const value$1 = input[key];\n          return [key, value$1, await item[\"~run\"]({\n            value: value$1\n          }, config$1)];\n        }));\n        for (const [key, value$1, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/map/map.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction map(key, value$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({\n            value: inputKey\n          }, config$1);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = keyDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"]({\n            value: inputValue\n          }, config$1);\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/map/mapAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapAsync(key, value$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */new Map();\n        const datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([inputKey, inputValue, this.key[\"~run\"]({\n          value: inputKey\n        }, config$1), this.value[\"~run\"]({\n          value: inputValue\n        }, config$1)])));\n        for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = keyDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nan/nan.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nan(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (Number.isNaN(dataset.value)) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/never/never.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction never(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullable(wrapped, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value !== null) dataset = this.wrapped[\"~run\"](dataset, config$1);\n      if (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullableAsync(wrapped, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (dataset.value !== null) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n      if (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullish(wrapped, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped[\"~run\"](dataset, config$1);\n      if (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullishAsync(wrapped, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n      if (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptional(wrapped, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value !== void 0) dataset = this.wrapped[\"~run\"](dataset, config$1);\n      if (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptionalAsync(wrapped, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (dataset.value !== void 0) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n      if (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/null/null.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction null_(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === null) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nullable/nullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) dataset.value = /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nullable/nullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) dataset.value = await /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nullish/nullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) dataset.value = /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/nullish/nullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) dataset.value = await /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/number/number.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction number(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/object/object.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction object(entries$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries: entries$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : /* @__PURE__ */getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value$1\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) dataset.issues = valueDataset.issues;\n              if (config$1.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) dataset.typed = false;\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config$1, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [{\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key,\n                value: input[key]\n              }]\n            });\n            if (config$1.abortEarly) break;\n          }\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/object/objectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectAsync(entries$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : await /* @__PURE__ */getDefault(valueSchema);\n            return [key, value$1, valueSchema, await valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1)];\n          }\n          return [key, input[key], valueSchema, null];\n        }));\n        for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) dataset.typed = false;\n          dataset.value[key] = valueDataset.value;\n        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n          _addIssue(this, \"key\", dataset, config$1, {\n            input: void 0,\n            expected: `\"${key}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key,\n              value: value$1\n            }]\n          });\n          if (config$1.abortEarly) break;\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRest(entries$1, rest, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries: entries$1,\n    rest,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : /* @__PURE__ */getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value$1\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) dataset.issues = valueDataset.issues;\n              if (config$1.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) dataset.typed = false;\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config$1, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [{\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key,\n                value: input[key]\n              }]\n            });\n            if (config$1.abortEarly) break;\n          }\n        }\n        if (!dataset.issues || !config$1.abortEarly) {\n          for (const key in input) if (/* @__PURE__ */_isValidObjectKey(input, key) && !(key in this.entries)) {\n            const valueDataset = this.rest[\"~run\"]({\n              value: input[key]\n            }, config$1);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: input[key]\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) dataset.issues = valueDataset.issues;\n              if (config$1.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) dataset.typed = false;\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRestAsync(entries$1, rest, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries$1,\n    rest,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : await /* @__PURE__ */getDefault(valueSchema);\n            return [key, value$1, valueSchema, await valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1)];\n          }\n          return [key, input[key], valueSchema, null];\n        })), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */_isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [key, value$1, await this.rest[\"~run\"]({\n          value: value$1\n        }, config$1)]))]);\n        for (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) dataset.typed = false;\n          dataset.value[key] = valueDataset.value;\n        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n          _addIssue(this, \"key\", dataset, config$1, {\n            input: void 0,\n            expected: `\"${key}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key,\n              value: value$1\n            }]\n          });\n          if (config$1.abortEarly) break;\n        }\n        if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) dataset.typed = false;\n          dataset.value[key] = valueDataset.value;\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/optional/optional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) dataset.value = /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/optional/optionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) dataset.value = await /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/picklist/picklist.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction picklist(options, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: /* @__PURE__ */_joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (this.options.includes(dataset.value)) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/promise/promise.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction promise(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value instanceof Promise) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/record/record.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction record(key, value$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) if (/* @__PURE__ */_isValidObjectKey(input, entryKey)) {\n          const entryValue = input[entryKey];\n          const keyDataset = this.key[\"~run\"]({\n            value: entryKey\n          }, config$1);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = keyDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"]({\n            value: entryValue\n          }, config$1);\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/record/recordAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction recordAsync(key, value$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */_isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([entryKey, entryValue, this.key[\"~run\"]({\n          value: entryKey\n        }, config$1), this.value[\"~run\"]({\n          value: entryValue\n        }, config$1)])));\n        for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = keyDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/set/set.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction set(value$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"]({\n            value: inputValue\n          }, config$1);\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) dataset.typed = false;\n          dataset.value.add(valueDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/set/setAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction setAsync(value$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */new Set();\n        const valueDatasets = await Promise.all([...input].map(async inputValue => [inputValue, await this.value[\"~run\"]({\n          value: inputValue\n        }, config$1)]));\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) dataset.typed = false;\n          dataset.value.add(valueDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObject(entries$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries: entries$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : /* @__PURE__ */getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value$1\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) dataset.issues = valueDataset.issues;\n              if (config$1.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) dataset.typed = false;\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config$1, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [{\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key,\n                value: input[key]\n              }]\n            });\n            if (config$1.abortEarly) break;\n          }\n        }\n        if (!dataset.issues || !config$1.abortEarly) {\n          for (const key in input) if (!(key in this.entries)) {\n            _addIssue(this, \"key\", dataset, config$1, {\n              input: key,\n              expected: \"never\",\n              path: [{\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key,\n                value: input[key]\n              }]\n            });\n            break;\n          }\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObjectAsync(entries$1, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries$1,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n            const value$1 = key in input ? input[key] : await /* @__PURE__ */getDefault(valueSchema);\n            return [key, value$1, valueSchema, await valueSchema[\"~run\"]({\n              value: value$1\n            }, config$1)];\n          }\n          return [key, input[key], valueSchema, null];\n        }));\n        for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = valueDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) dataset.typed = false;\n          dataset.value[key] = valueDataset.value;\n        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */getFallback(valueSchema);else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n          _addIssue(this, \"key\", dataset, config$1, {\n            input: void 0,\n            expected: `\"${key}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key,\n              value: value$1\n            }]\n          });\n          if (config$1.abortEarly) break;\n        }\n        if (!dataset.issues || !config$1.abortEarly) {\n          for (const key in input) if (!(key in this.entries)) {\n            _addIssue(this, \"key\", dataset, config$1, {\n              input: key,\n              expected: \"never\",\n              path: [{\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key,\n                value: input[key]\n              }]\n            });\n            break;\n          }\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTuple(items, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value$1 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({\n            value: value$1\n          }, config$1);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n          input: input[this.items.length],\n          expected: \"never\",\n          path: [{\n            type: \"array\",\n            origin: \"value\",\n            input,\n            key: this.items.length,\n            value: input[this.items.length]\n          }]\n        });\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTupleAsync(items, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n          const value$1 = input[key];\n          return [key, value$1, await item[\"~run\"]({\n            value: value$1\n          }, config$1)];\n        }));\n        for (const [key, value$1, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n          input: input[this.items.length],\n          expected: \"never\",\n          path: [{\n            type: \"array\",\n            origin: \"value\",\n            input,\n            key: this.items.length,\n            value: input[this.items.length]\n          }]\n        });\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/string/string.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction string(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (typeof dataset.value === \"string\") dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/symbol/symbol.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction symbol(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (typeof dataset.value === \"symbol\") dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/tuple/tuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tuple(items, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value$1 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({\n            value: value$1\n          }, config$1);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/tuple/tupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleAsync(items, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n          const value$1 = input[key];\n          return [key, value$1, await item[\"~run\"]({\n            value: value$1\n          }, config$1)];\n        }));\n        for (const [key, value$1, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRest(items, rest, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value$1 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({\n            value: value$1\n          }, config$1);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {\n          const value$1 = input[key];\n          const itemDataset = this.rest[\"~run\"]({\n            value: value$1\n          }, config$1);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRestAsync(items, rest, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {\n          const value$1 = input[key];\n          return [key, value$1, await item[\"~run\"]({\n            value: value$1\n          }, config$1)];\n        })), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {\n          return [key + this.items.length, value$1, await this.rest[\"~run\"]({\n            value: value$1\n          }, config$1)];\n        }))]);\n        for (const [key, value$1, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value$1\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) issue.path.unshift(pathItem);else issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) dataset.issues = itemDataset.issues;\n            if (config$1.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) dataset.typed = false;\n          dataset.value.push(itemDataset.value);\n        }\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/undefined/undefined.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefined_(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === void 0) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) dataset.value = /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) dataset.value = await /* @__PURE__ */getDefault(this, dataset, config$1);\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config$1);\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/union/utils/_subIssues/_subIssues.ts\n/**\n* Returns the sub issues of the provided datasets for the union issue.\n*\n* @param datasets The datasets.\n*\n* @returns The sub issues.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);else issues = dataset.issues;\n  return issues;\n}\n\n//#endregion\n//#region src/schemas/union/union.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction union(options, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: /* @__PURE__ */_joinExpects(options.map(option => option.expects), \"|\"),\n    async: false,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({\n          value: dataset.value\n        }, config$1);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) typedDatasets.push(optionDataset);else typedDatasets = [optionDataset];\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else if (untypedDatasets) untypedDatasets.push(optionDataset);else untypedDatasets = [optionDataset];\n      }\n      if (validDataset) return validDataset;\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) return typedDatasets[0];\n        _addIssue(this, \"type\", dataset, config$1, {\n          issues: /* @__PURE__ */_subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];else _addIssue(this, \"type\", dataset, config$1, {\n        issues: /* @__PURE__ */_subIssues(untypedDatasets)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/union/unionAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction unionAsync(options, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: /* @__PURE__ */_joinExpects(options.map(option => option.expects), \"|\"),\n    async: true,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"]({\n          value: dataset.value\n        }, config$1);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) typedDatasets.push(optionDataset);else typedDatasets = [optionDataset];\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else if (untypedDatasets) untypedDatasets.push(optionDataset);else untypedDatasets = [optionDataset];\n      }\n      if (validDataset) return validDataset;\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) return typedDatasets[0];\n        _addIssue(this, \"type\", dataset, config$1, {\n          issues: /* @__PURE__ */_subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];else _addIssue(this, \"type\", dataset, config$1, {\n        issues: /* @__PURE__ */_subIssues(untypedDatasets)\n      });\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/unknown/unknown.ts\n/**\n* Creates a unknown schema.\n*\n* @returns A unknown schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/variant/variant.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variant(key, options, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant$1, allKeys) => {\n          for (const schema of variant$1.options) {\n            if (schema.type === \"variant\") parseOptions(schema, new Set(allKeys).add(schema.key));else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? discriminatorSchema[\"~run\"]({\n                  typed: false,\n                  value: input[currentKey]\n                }, {\n                  abortEarly: true\n                }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({\n                  value: input\n                }, config$1);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n              }\n            }\n            if (outputDataset && !outputDataset.issues) break;\n          }\n        };\n        parseOptions(this, new Set([this.key]));\n        if (outputDataset) return outputDataset;\n        _addIssue(this, \"type\", dataset, config$1, {\n          input: input[invalidDiscriminatorKey],\n          expected: /* @__PURE__ */_joinExpects(expectedDiscriminators, \"|\"),\n          path: [{\n            type: \"object\",\n            origin: \"value\",\n            input,\n            key: invalidDiscriminatorKey,\n            value: input[invalidDiscriminatorKey]\n          }]\n        });\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/variant/variantAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variantAsync(key, options, message$1) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant$1, allKeys) => {\n          for (const schema of variant$1.options) {\n            if (schema.type === \"variant\") await parseOptions(schema, new Set(allKeys).add(schema.key));else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? (await discriminatorSchema[\"~run\"]({\n                  typed: false,\n                  value: input[currentKey]\n                }, {\n                  abortEarly: true\n                })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"]({\n                  value: input\n                }, config$1);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n              }\n            }\n            if (outputDataset && !outputDataset.issues) break;\n          }\n        };\n        await parseOptions(this, new Set([this.key]));\n        if (outputDataset) return outputDataset;\n        _addIssue(this, \"type\", dataset, config$1, {\n          input: input[invalidDiscriminatorKey],\n          expected: /* @__PURE__ */_joinExpects(expectedDiscriminators, \"|\"),\n          path: [{\n            type: \"object\",\n            origin: \"value\",\n            input,\n            key: invalidDiscriminatorKey,\n            value: input[invalidDiscriminatorKey]\n          }]\n        });\n      } else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/schemas/void/void.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction void_(message$1) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message: message$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      if (dataset.value === void 0) dataset.typed = true;else _addIssue(this, \"type\", dataset, config$1);\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/keyof/keyof.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction keyof(schema, message$1) {\n  return /* @__PURE__ */picklist(Object.keys(schema.entries), message$1);\n}\n\n//#endregion\n//#region src/methods/message/message.ts\n/**\n* Changes the local message configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param message_ The error message.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction message(schema, message_) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      return schema[\"~run\"](dataset, {\n        ...config$1,\n        message: message_\n      });\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/omit/omit.ts\n/**\n* Creates a modified copy of an object schema that does not contain the\n* selected entries.\n*\n* @param schema The schema to omit from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction omit(schema, keys) {\n  const entries$1 = {\n    ...schema.entries\n  };\n  for (const key of keys) delete entries$1[key];\n  return {\n    ...schema,\n    entries: entries$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/parse/parse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nfunction parse(schema, input, config$1) {\n  const dataset = schema[\"~run\"]({\n    value: input\n  }, /* @__PURE__ */getGlobalConfig(config$1));\n  if (dataset.issues) throw new ValiError(dataset.issues);\n  return dataset.value;\n}\n\n//#endregion\n//#region src/methods/parse/parseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nasync function parseAsync(schema, input, config$1) {\n  const dataset = await schema[\"~run\"]({\n    value: input\n  }, /* @__PURE__ */getGlobalConfig(config$1));\n  if (dataset.issues) throw new ValiError(dataset.issues);\n  return dataset.value;\n}\n\n//#endregion\n//#region src/methods/parser/parser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parser(schema, config$1) {\n  const func = input => parse(schema, input, config$1);\n  func.schema = schema;\n  func.config = config$1;\n  return func;\n}\n\n//#endregion\n//#region src/methods/parser/parserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parserAsync(schema, config$1) {\n  const func = input => parseAsync(schema, input, config$1);\n  func.schema = schema;\n  func.config = config$1;\n  return func;\n}\n\n//#endregion\n//#region src/methods/partial/partial.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partial(schema, keys) {\n  const entries$1 = {};\n  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */optional(schema.entries[key]) : schema.entries[key];\n  return {\n    ...schema,\n    entries: entries$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/partial/partialAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialAsync(schema, keys) {\n  const entries$1 = {};\n  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */optionalAsync(schema.entries[key]) : schema.entries[key];\n  return {\n    ...schema,\n    entries: entries$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/pick/pick.ts\n/**\n* Creates a modified copy of an object schema that contains only the selected\n* entries.\n*\n* @param schema The schema to pick from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction pick(schema, keys) {\n  const entries$1 = {};\n  for (const key of keys) entries$1[key] = schema.entries[key];\n  return {\n    ...schema,\n    entries: entries$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/pipe/pipe.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipe(...pipe$1) {\n  return {\n    ...pipe$1[0],\n    pipe: pipe$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    \"~run\"(dataset, config$1) {\n      for (const item of pipe$1) if (item.kind !== \"metadata\") {\n        if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item[\"~run\"](dataset, config$1);\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/pipe/pipeAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipeAsync(...pipe$1) {\n  return {\n    ...pipe$1[0],\n    pipe: pipe$1,\n    async: true,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    },\n    async \"~run\"(dataset, config$1) {\n      for (const item of pipe$1) if (item.kind !== \"metadata\") {\n        if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item[\"~run\"](dataset, config$1);\n      }\n      return dataset;\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/required/required.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message$1 = Array.isArray(arg2) ? arg3 : arg2;\n  const entries$1 = {};\n  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */nonOptional(schema.entries[key], message$1) : schema.entries[key];\n  return {\n    ...schema,\n    entries: entries$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/required/requiredAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message$1 = Array.isArray(arg2) ? arg3 : arg2;\n  const entries$1 = {};\n  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];\n  return {\n    ...schema,\n    entries: entries$1,\n    get \"~standard\"() {\n      return /* @__PURE__ */_getStandardProps(this);\n    }\n  };\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParse(schema, input, config$1) {\n  const dataset = schema[\"~run\"]({\n    value: input\n  }, /* @__PURE__ */getGlobalConfig(config$1));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function safeParseAsync(schema, input, config$1) {\n  const dataset = await schema[\"~run\"]({\n    value: input\n  }, /* @__PURE__ */getGlobalConfig(config$1));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParser(schema, config$1) {\n  const func = input => /* @__PURE__ */safeParse(schema, input, config$1);\n  func.schema = schema;\n  func.config = config$1;\n  return func;\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParserAsync(schema, config$1) {\n  const func = input => /* @__PURE__ */safeParseAsync(schema, input, config$1);\n  func.schema = schema;\n  func.config = config$1;\n  return func;\n}\n\n//#endregion\n//#region src/methods/summarize/summarize.ts\n/**\n* Summarize the error messages of issues in a pretty-printable multi-line string.\n*\n* @param issues The list of issues.\n*\n* @returns A summary of the issues.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction summarize(issues) {\n  let summary = \"\";\n  for (const issue of issues) {\n    if (summary) summary += \"\\n\";\n    summary += ` ${issue.message}`;\n    const dotPath = /* @__PURE__ */getDotPath(issue);\n    if (dotPath) summary += `\\n   at ${dotPath}`;\n  }\n  return summary;\n}\n\n//#endregion\n//#region src/methods/unwrap/unwrap.ts\n/**\n* Unwraps the wrapped schema.\n*\n* @param schema The schema to be unwrapped.\n*\n* @returns The unwrapped schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n//#endregion\nexport { BASE64_REGEX, BIC_REGEX, CUID2_REGEX, DECIMAL_REGEX, DIGITS_REGEX, EMAIL_REGEX, EMOJI_REGEX, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, IP_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, MAC48_REGEX, MAC64_REGEX, MAC_REGEX, NANO_ID_REGEX, OCTAL_REGEX, RFC_EMAIL_REGEX, SLUG_REGEX, ULID_REGEX, UUID_REGEX, ValiError, _addIssue, _getByteCount, _getGraphemeCount, _getLastMetadata, _getStandardProps, _getWordCount, _isLuhnAlgo, _isValidObjectKey, _joinExpects, _stringify, any, args, argsAsync, array, arrayAsync, assert, awaitAsync, base64, bic, bigint, blob, boolean, brand, bytes, check, checkAsync, checkItems, checkItemsAsync, config, creditCard, cuid2, custom, customAsync, date, decimal, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, description, digits, email, emoji, empty, endsWith, entries, entriesFromList, entriesFromObjects, enum_ as enum, enum_, everyItem, exactOptional, exactOptionalAsync, examples, excludes, fallback, fallbackAsync, file, filterItems, findItem, finite, flatten, flavor, forward, forwardAsync, function_ as function, function_, getDefault, getDefaults, getDefaultsAsync, getDescription, getDotPath, getExamples, getFallback, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getMetadata, getSchemaMessage, getSpecificMessage, getTitle, graphemes, gtValue, hash, hexColor, hexadecimal, imei, includes, instance, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isOfKind, isOfType, isValiError, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, looseObject, looseObjectAsync, looseTuple, looseTupleAsync, ltValue, mac, mac48, mac64, map, mapAsync, mapItems, maxBytes, maxEntries, maxGraphemes, maxLength, maxSize, maxValue, maxWords, message, metadata, mimeType, minBytes, minEntries, minGraphemes, minLength, minSize, minValue, minWords, multipleOf, nan, nanoid, never, nonEmpty, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, normalize, notBytes, notEntries, notGraphemes, notLength, notSize, notValue, notValues, notWords, null_ as null, null_, nullable, nullableAsync, nullish, nullishAsync, number, object, objectAsync, objectWithRest, objectWithRestAsync, octal, omit, optional, optionalAsync, parse, parseAsync, parseJson, parser, parserAsync, partial, partialAsync, partialCheck, partialCheckAsync, pick, picklist, pipe, pipeAsync, promise, rawCheck, rawCheckAsync, rawTransform, rawTransformAsync, readonly, record, recordAsync, reduceItems, regex, required, requiredAsync, returns, returnsAsync, rfcEmail, safeInteger, safeParse, safeParseAsync, safeParser, safeParserAsync, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, slug, someItem, sortItems, startsWith, strictObject, strictObjectAsync, strictTuple, strictTupleAsync, string, stringifyJson, summarize, symbol, title, toBigint, toBoolean, toDate, toLowerCase, toMaxValue, toMinValue, toNumber, toString, toUpperCase, transform, transformAsync, trim, trimEnd, trimStart, tuple, tupleAsync, tupleWithRest, tupleWithRestAsync, ulid, undefined_ as undefined, undefined_, undefinedable, undefinedableAsync, union, unionAsync, unknown, unwrap, url, uuid, value, values, variant, variantAsync, void_ as void, void_, words };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}