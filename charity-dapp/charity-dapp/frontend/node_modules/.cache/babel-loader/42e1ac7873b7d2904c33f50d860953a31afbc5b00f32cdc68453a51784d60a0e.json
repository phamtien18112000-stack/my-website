{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _caches, _cache, _onEffects;\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nclass AsyncCache {\n  async getObject(id) {\n    const [owned, shared] = await Promise.all([this.get(\"OwnedObject\", id), this.get(\"SharedOrImmutableObject\", id)]);\n    return owned ?? shared ?? null;\n  }\n  async getObjects(ids) {\n    return Promise.all([...ids.map(id => this.getObject(id))]);\n  }\n  async addObject(object) {\n    if (object.owner) {\n      await this.set(\"OwnedObject\", object.objectId, object);\n    } else {\n      await this.set(\"SharedOrImmutableObject\", object.objectId, object);\n    }\n    return object;\n  }\n  async addObjects(objects) {\n    await Promise.all(objects.map(async object => this.addObject(object)));\n  }\n  async deleteObject(id) {\n    await Promise.all([this.delete(\"OwnedObject\", id), this.delete(\"SharedOrImmutableObject\", id)]);\n  }\n  async deleteObjects(ids) {\n    await Promise.all(ids.map(id => this.deleteObject(id)));\n  }\n  async getMoveFunctionDefinition(ref) {\n    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n    return this.get(\"MoveFunction\", functionName);\n  }\n  async addMoveFunctionDefinition(functionEntry) {\n    const pkg = normalizeSuiAddress(functionEntry.package);\n    const functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;\n    const entry = {\n      ...functionEntry,\n      package: pkg\n    };\n    await this.set(\"MoveFunction\", functionName, entry);\n    return entry;\n  }\n  async deleteMoveFunctionDefinition(ref) {\n    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;\n    await this.delete(\"MoveFunction\", functionName);\n  }\n  async getCustom(key) {\n    return this.get(\"Custom\", key);\n  }\n  async setCustom(key, value) {\n    return this.set(\"Custom\", key, value);\n  }\n  async deleteCustom(key) {\n    return this.delete(\"Custom\", key);\n  }\n}\nclass InMemoryCache extends AsyncCache {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _caches, {\n      OwnedObject: /* @__PURE__ */new Map(),\n      SharedOrImmutableObject: /* @__PURE__ */new Map(),\n      MoveFunction: /* @__PURE__ */new Map(),\n      Custom: /* @__PURE__ */new Map()\n    });\n  }\n  async get(type, key) {\n    return __privateGet(this, _caches)[type].get(key) ?? null;\n  }\n  async set(type, key, value) {\n    __privateGet(this, _caches)[type].set(key, value);\n  }\n  async delete(type, key) {\n    __privateGet(this, _caches)[type].delete(key);\n  }\n  async clear(type) {\n    if (type) {\n      __privateGet(this, _caches)[type].clear();\n    } else {\n      for (const cache of Object.values(__privateGet(this, _caches))) {\n        cache.clear();\n      }\n    }\n  }\n}\n_caches = new WeakMap();\nclass ObjectCache {\n  constructor({\n    cache = new InMemoryCache(),\n    onEffects\n  }) {\n    __privateAdd(this, _cache);\n    __privateAdd(this, _onEffects);\n    __privateSet(this, _cache, cache);\n    __privateSet(this, _onEffects, onEffects);\n  }\n  asPlugin() {\n    return async (transactionData, _options, next) => {\n      const unresolvedObjects = transactionData.inputs.filter(input => input.UnresolvedObject).map(input => input.UnresolvedObject.objectId);\n      const cached = (await __privateGet(this, _cache).getObjects(unresolvedObjects)).filter(obj => obj !== null);\n      const byId = new Map(cached.map(obj => [obj.objectId, obj]));\n      for (const input of transactionData.inputs) {\n        if (!input.UnresolvedObject) {\n          continue;\n        }\n        const cached2 = byId.get(input.UnresolvedObject.objectId);\n        if (!cached2) {\n          continue;\n        }\n        if (cached2.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {\n          input.UnresolvedObject.initialSharedVersion = cached2.initialSharedVersion;\n        } else {\n          if (cached2.version && !input.UnresolvedObject.version) {\n            input.UnresolvedObject.version = cached2.version;\n          }\n          if (cached2.digest && !input.UnresolvedObject.digest) {\n            input.UnresolvedObject.digest = cached2.digest;\n          }\n        }\n      }\n      await Promise.all(transactionData.commands.map(async commands => {\n        if (commands.MoveCall) {\n          const def = await this.getMoveFunctionDefinition({\n            package: commands.MoveCall.package,\n            module: commands.MoveCall.module,\n            function: commands.MoveCall.function\n          });\n          if (def) {\n            commands.MoveCall._argumentTypes = def.parameters;\n          }\n        }\n      }));\n      await next();\n      await Promise.all(transactionData.commands.map(async commands => {\n        if (commands.MoveCall?._argumentTypes) {\n          await __privateGet(this, _cache).addMoveFunctionDefinition({\n            package: commands.MoveCall.package,\n            module: commands.MoveCall.module,\n            function: commands.MoveCall.function,\n            parameters: commands.MoveCall._argumentTypes\n          });\n        }\n      }));\n    };\n  }\n  async clear() {\n    await __privateGet(this, _cache).clear();\n  }\n  async getMoveFunctionDefinition(ref) {\n    return __privateGet(this, _cache).getMoveFunctionDefinition(ref);\n  }\n  async getObjects(ids) {\n    return __privateGet(this, _cache).getObjects(ids);\n  }\n  async deleteObjects(ids) {\n    return __privateGet(this, _cache).deleteObjects(ids);\n  }\n  async clearOwnedObjects() {\n    await __privateGet(this, _cache).clear(\"OwnedObject\");\n  }\n  async clearCustom() {\n    await __privateGet(this, _cache).clear(\"Custom\");\n  }\n  async getCustom(key) {\n    return __privateGet(this, _cache).getCustom(key);\n  }\n  async setCustom(key, value) {\n    return __privateGet(this, _cache).setCustom(key, value);\n  }\n  async deleteCustom(key) {\n    return __privateGet(this, _cache).deleteCustom(key);\n  }\n  async applyEffects(effects) {\n    var _a;\n    if (!effects.V2) {\n      throw new Error(`Unsupported transaction effects version ${effects.$kind}`);\n    }\n    const {\n      lamportVersion,\n      changedObjects\n    } = effects.V2;\n    const deletedIds = [];\n    const addedObjects = [];\n    changedObjects.forEach(([id, change]) => {\n      if (change.outputState.NotExist) {\n        deletedIds.push(id);\n      } else if (change.outputState.ObjectWrite) {\n        const [digest, owner] = change.outputState.ObjectWrite;\n        addedObjects.push({\n          objectId: id,\n          digest,\n          version: lamportVersion,\n          owner: owner.AddressOwner ?? owner.ObjectOwner ?? null,\n          initialSharedVersion: owner.Shared?.initialSharedVersion ?? null\n        });\n      }\n    });\n    await Promise.all([__privateGet(this, _cache).addObjects(addedObjects), __privateGet(this, _cache).deleteObjects(deletedIds), (_a = __privateGet(this, _onEffects)) == null ? void 0 : _a.call(this, effects)]);\n  }\n}\n_cache = new WeakMap();\n_onEffects = new WeakMap();\nexport { AsyncCache, InMemoryCache, ObjectCache };\n//# sourceMappingURL=ObjectCache.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}