{"ast":null,"code":"import { fromBase58, toBase64, toHex } from \"@mysten/bcs\";\nimport { isTransaction } from \"../transactions/index.js\";\nimport { isValidSuiAddress, isValidSuiObjectId, isValidTransactionDigest, normalizeSuiAddress, normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { normalizeSuiNSName } from \"../utils/suins.js\";\nimport { SuiHTTPTransport } from \"./http-transport.js\";\nconst SUI_CLIENT_BRAND = Symbol.for(\"@mysten/SuiClient\");\nfunction isSuiClient(client) {\n  return typeof client === \"object\" && client !== null && client[SUI_CLIENT_BRAND] === true;\n}\nclass SuiClient {\n  get [SUI_CLIENT_BRAND]() {\n    return true;\n  }\n  /**\n   * Establish a connection to a Sui RPC endpoint\n   *\n   * @param options configuration options for the API Client\n   */\n  constructor(options) {\n    this.transport = options.transport ?? new SuiHTTPTransport({\n      url: options.url\n    });\n  }\n  async getRpcApiVersion() {\n    const resp = await this.transport.request({\n      method: \"rpc.discover\",\n      params: []\n    });\n    return resp.info.version;\n  }\n  /**\n   * Get all Coin<`coin_type`> objects owned by an address.\n   */\n  async getCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getCoins\",\n      params: [input.owner, input.coinType, input.cursor, input.limit]\n    });\n  }\n  /**\n   * Get all Coin objects owned by an address.\n   */\n  async getAllCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getAllCoins\",\n      params: [input.owner, input.cursor, input.limit]\n    });\n  }\n  /**\n   * Get the total coin balance for one coin type, owned by the address owner.\n   */\n  async getBalance(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getBalance\",\n      params: [input.owner, input.coinType]\n    });\n  }\n  /**\n   * Get the total coin balance for all coin types, owned by the address owner.\n   */\n  async getAllBalances(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getAllBalances\",\n      params: [input.owner]\n    });\n  }\n  /**\n   * Fetch CoinMetadata for a given coin type\n   */\n  async getCoinMetadata(input) {\n    return await this.transport.request({\n      method: \"suix_getCoinMetadata\",\n      params: [input.coinType]\n    });\n  }\n  /**\n   *  Fetch total supply for a coin\n   */\n  async getTotalSupply(input) {\n    return await this.transport.request({\n      method: \"suix_getTotalSupply\",\n      params: [input.coinType]\n    });\n  }\n  /**\n   * Invoke any RPC method\n   * @param method the method to be invoked\n   * @param args the arguments to be passed to the RPC request\n   */\n  async call(method, params) {\n    return await this.transport.request({\n      method,\n      params\n    });\n  }\n  /**\n   * Get Move function argument types like read, write and full access\n   */\n  async getMoveFunctionArgTypes(input) {\n    return await this.transport.request({\n      method: \"sui_getMoveFunctionArgTypes\",\n      params: [input.package, input.module, input.function]\n    });\n  }\n  /**\n   * Get a map from module name to\n   * structured representations of Move modules\n   */\n  async getNormalizedMoveModulesByPackage(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveModulesByPackage\",\n      params: [input.package]\n    });\n  }\n  /**\n   * Get a structured representation of Move module\n   */\n  async getNormalizedMoveModule(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveModule\",\n      params: [input.package, input.module]\n    });\n  }\n  /**\n   * Get a structured representation of Move function\n   */\n  async getNormalizedMoveFunction(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveFunction\",\n      params: [input.package, input.module, input.function]\n    });\n  }\n  /**\n   * Get a structured representation of Move struct\n   */\n  async getNormalizedMoveStruct(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveStruct\",\n      params: [input.package, input.module, input.struct]\n    });\n  }\n  /**\n   * Get all objects owned by an address\n   */\n  async getOwnedObjects(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getOwnedObjects\",\n      params: [input.owner, {\n        filter: input.filter,\n        options: input.options\n      }, input.cursor, input.limit]\n    });\n  }\n  /**\n   * Get details about an object\n   */\n  async getObject(input) {\n    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.transport.request({\n      method: \"sui_getObject\",\n      params: [input.id, input.options]\n    });\n  }\n  async tryGetPastObject(input) {\n    return await this.transport.request({\n      method: \"sui_tryGetPastObject\",\n      params: [input.id, input.version, input.options]\n    });\n  }\n  /**\n   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n   */\n  async multiGetObjects(input) {\n    input.ids.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Object id ${id}`);\n      }\n    });\n    const hasDuplicates = input.ids.length !== new Set(input.ids).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate object ids in batch call ${input.ids}`);\n    }\n    return await this.transport.request({\n      method: \"sui_multiGetObjects\",\n      params: [input.ids, input.options]\n    });\n  }\n  /**\n   * Get transaction blocks for a given query criteria\n   */\n  async queryTransactionBlocks(input) {\n    return await this.transport.request({\n      method: \"suix_queryTransactionBlocks\",\n      params: [{\n        filter: input.filter,\n        options: input.options\n      }, input.cursor, input.limit, (input.order || \"descending\") === \"descending\"]\n    });\n  }\n  async getTransactionBlock(input) {\n    if (!isValidTransactionDigest(input.digest)) {\n      throw new Error(\"Invalid Transaction digest\");\n    }\n    return await this.transport.request({\n      method: \"sui_getTransactionBlock\",\n      params: [input.digest, input.options]\n    });\n  }\n  async multiGetTransactionBlocks(input) {\n    input.digests.forEach(d => {\n      if (!isValidTransactionDigest(d)) {\n        throw new Error(`Invalid Transaction digest ${d}`);\n      }\n    });\n    const hasDuplicates = input.digests.length !== new Set(input.digests).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate digests in batch call ${input.digests}`);\n    }\n    return await this.transport.request({\n      method: \"sui_multiGetTransactionBlocks\",\n      params: [input.digests, input.options]\n    });\n  }\n  async executeTransactionBlock({\n    transactionBlock,\n    signature,\n    options,\n    requestType\n  }) {\n    const result = await this.transport.request({\n      method: \"sui_executeTransactionBlock\",\n      params: [typeof transactionBlock === \"string\" ? transactionBlock : toBase64(transactionBlock), Array.isArray(signature) ? signature : [signature], options]\n    });\n    if (requestType === \"WaitForLocalExecution\") {\n      try {\n        await this.waitForTransaction({\n          digest: result.digest\n        });\n      } catch (_) {}\n    }\n    return result;\n  }\n  async signAndExecuteTransaction({\n    transaction,\n    signer,\n    ...input\n  }) {\n    let transactionBytes;\n    if (transaction instanceof Uint8Array) {\n      transactionBytes = transaction;\n    } else {\n      transaction.setSenderIfNotSet(signer.toSuiAddress());\n      transactionBytes = await transaction.build({\n        client: this\n      });\n    }\n    const {\n      signature,\n      bytes\n    } = await signer.signTransaction(transactionBytes);\n    return this.executeTransactionBlock({\n      transactionBlock: bytes,\n      signature,\n      ...input\n    });\n  }\n  /**\n   * Get total number of transactions\n   */\n  async getTotalTransactionBlocks() {\n    const resp = await this.transport.request({\n      method: \"sui_getTotalTransactionBlocks\",\n      params: []\n    });\n    return BigInt(resp);\n  }\n  /**\n   * Getting the reference gas price for the network\n   */\n  async getReferenceGasPrice() {\n    const resp = await this.transport.request({\n      method: \"suix_getReferenceGasPrice\",\n      params: []\n    });\n    return BigInt(resp);\n  }\n  /**\n   * Return the delegated stakes for an address\n   */\n  async getStakes(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getStakes\",\n      params: [input.owner]\n    });\n  }\n  /**\n   * Return the delegated stakes queried by id.\n   */\n  async getStakesByIds(input) {\n    input.stakedSuiIds.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Stake id ${id}`);\n      }\n    });\n    return await this.transport.request({\n      method: \"suix_getStakesByIds\",\n      params: [input.stakedSuiIds]\n    });\n  }\n  /**\n   * Return the latest system state content.\n   */\n  async getLatestSuiSystemState() {\n    return await this.transport.request({\n      method: \"suix_getLatestSuiSystemState\",\n      params: []\n    });\n  }\n  /**\n   * Get events for a given query criteria\n   */\n  async queryEvents(input) {\n    return await this.transport.request({\n      method: \"suix_queryEvents\",\n      params: [input.query, input.cursor, input.limit, (input.order || \"descending\") === \"descending\"]\n    });\n  }\n  /**\n   * Subscribe to get notifications whenever an event matching the filter occurs\n   *\n   * @deprecated\n   */\n  async subscribeEvent(input) {\n    return this.transport.subscribe({\n      method: \"suix_subscribeEvent\",\n      unsubscribe: \"suix_unsubscribeEvent\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  /**\n   * @deprecated\n   */\n  async subscribeTransaction(input) {\n    return this.transport.subscribe({\n      method: \"suix_subscribeTransaction\",\n      unsubscribe: \"suix_unsubscribeTransaction\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  /**\n   * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input) {\n    let devInspectTxBytes;\n    if (isTransaction(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(input.sender);\n      devInspectTxBytes = toBase64(await input.transactionBlock.build({\n        client: this,\n        onlyTransactionKind: true\n      }));\n    } else if (typeof input.transactionBlock === \"string\") {\n      devInspectTxBytes = input.transactionBlock;\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      devInspectTxBytes = toBase64(input.transactionBlock);\n    } else {\n      throw new Error(\"Unknown transaction block format.\");\n    }\n    return await this.transport.request({\n      method: \"sui_devInspectTransactionBlock\",\n      params: [input.sender, devInspectTxBytes, input.gasPrice?.toString(), input.epoch]\n    });\n  }\n  /**\n   * Dry run a transaction block and return the result.\n   */\n  async dryRunTransactionBlock(input) {\n    return await this.transport.request({\n      method: \"sui_dryRunTransactionBlock\",\n      params: [typeof input.transactionBlock === \"string\" ? input.transactionBlock : toBase64(input.transactionBlock)]\n    });\n  }\n  /**\n   * Return the list of dynamic field objects owned by an object\n   */\n  async getDynamicFields(input) {\n    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.transport.request({\n      method: \"suix_getDynamicFields\",\n      params: [input.parentId, input.cursor, input.limit]\n    });\n  }\n  /**\n   * Return the dynamic field object information for a specified object\n   */\n  async getDynamicFieldObject(input) {\n    return await this.transport.request({\n      method: \"suix_getDynamicFieldObject\",\n      params: [input.parentId, input.name]\n    });\n  }\n  /**\n   * Get the sequence number of the latest checkpoint that has been executed\n   */\n  async getLatestCheckpointSequenceNumber() {\n    const resp = await this.transport.request({\n      method: \"sui_getLatestCheckpointSequenceNumber\",\n      params: []\n    });\n    return String(resp);\n  }\n  /**\n   * Returns information about a given checkpoint\n   */\n  async getCheckpoint(input) {\n    return await this.transport.request({\n      method: \"sui_getCheckpoint\",\n      params: [input.id]\n    });\n  }\n  /**\n   * Returns historical checkpoints paginated\n   */\n  async getCheckpoints(input) {\n    return await this.transport.request({\n      method: \"sui_getCheckpoints\",\n      params: [input.cursor, input?.limit, input.descendingOrder]\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCommitteeInfo(input) {\n    return await this.transport.request({\n      method: \"suix_getCommitteeInfo\",\n      params: [input?.epoch]\n    });\n  }\n  async getNetworkMetrics() {\n    return await this.transport.request({\n      method: \"suix_getNetworkMetrics\",\n      params: []\n    });\n  }\n  async getAddressMetrics() {\n    return await this.transport.request({\n      method: \"suix_getLatestAddressMetrics\",\n      params: []\n    });\n  }\n  async getEpochMetrics(input) {\n    return await this.transport.request({\n      method: \"suix_getEpochMetrics\",\n      params: [input?.cursor, input?.limit, input?.descendingOrder]\n    });\n  }\n  async getAllEpochAddressMetrics(input) {\n    return await this.transport.request({\n      method: \"suix_getAllEpochAddressMetrics\",\n      params: [input?.descendingOrder]\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getEpochs(input) {\n    return await this.transport.request({\n      method: \"suix_getEpochs\",\n      params: [input?.cursor, input?.limit, input?.descendingOrder]\n    });\n  }\n  /**\n   * Returns list of top move calls by usage\n   */\n  async getMoveCallMetrics() {\n    return await this.transport.request({\n      method: \"suix_getMoveCallMetrics\",\n      params: []\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCurrentEpoch() {\n    return await this.transport.request({\n      method: \"suix_getCurrentEpoch\",\n      params: []\n    });\n  }\n  /**\n   * Return the Validators APYs\n   */\n  async getValidatorsApy() {\n    return await this.transport.request({\n      method: \"suix_getValidatorsApy\",\n      params: []\n    });\n  }\n  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n  async getChainIdentifier() {\n    const checkpoint = await this.getCheckpoint({\n      id: \"0\"\n    });\n    const bytes = fromBase58(checkpoint.digest);\n    return toHex(bytes.slice(0, 4));\n  }\n  async resolveNameServiceAddress(input) {\n    return await this.transport.request({\n      method: \"suix_resolveNameServiceAddress\",\n      params: [input.name]\n    });\n  }\n  async resolveNameServiceNames({\n    format = \"dot\",\n    ...input\n  }) {\n    const {\n      nextCursor,\n      hasNextPage,\n      data\n    } = await this.transport.request({\n      method: \"suix_resolveNameServiceNames\",\n      params: [input.address, input.cursor, input.limit]\n    });\n    return {\n      hasNextPage,\n      nextCursor,\n      data: data.map(name => normalizeSuiNSName(name, format))\n    };\n  }\n  async getProtocolConfig(input) {\n    return await this.transport.request({\n      method: \"sui_getProtocolConfig\",\n      params: [input?.version]\n    });\n  }\n  /**\n   * Wait for a transaction block result to be available over the API.\n   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n   * be available via the API.\n   * This currently polls the `getTransactionBlock` API to check for the transaction.\n   */\n  async waitForTransaction({\n    signal,\n    timeout = 60 * 1e3,\n    pollInterval = 2 * 1e3,\n    ...input\n  }) {\n    const timeoutSignal = AbortSignal.timeout(timeout);\n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutSignal.addEventListener(\"abort\", () => reject(timeoutSignal.reason));\n    });\n    timeoutPromise.catch(() => {});\n    while (!timeoutSignal.aborted) {\n      signal?.throwIfAborted();\n      try {\n        return await this.getTransactionBlock(input);\n      } catch (e) {\n        await Promise.race([new Promise(resolve => setTimeout(resolve, pollInterval)), timeoutPromise]);\n      }\n    }\n    timeoutSignal.throwIfAborted();\n    throw new Error(\"Unexpected error while waiting for transaction block.\");\n  }\n}\nexport { SuiClient, isSuiClient };\n//# sourceMappingURL=client.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}